{"README.md":"\n> Open this page at GitHub Pages: [https://jp-rad.github.io/pxt-mstate/](https://jp-rad.github.io/pxt-mstate/)\n\n## Creating Extensions\n\nExtensions are PXTâ€™s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\n\n* [MakeCode extensions](https://makecode.com/extensions)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-rad/pxt-mstate** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-rad/pxt-mstate/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-rad/pxt-mstate** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/statics/blocks.png)\n\n\n**Example**\n\n```javascript\nlet blink = 0\nfunction blinkLED () {\n    led.setBrightness(blink * 155 + 100)\n    blink += 1\n    blink = blink % 2\n}\nmstate.defineStateName(\"State1\", function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        blink = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareDo(STATE, 500, function () {\n        blinkLED()\n    })\n    mstate.declareExit(STATE, function (next) {\n        led.setBrightness(255)\n        basic.showIcon(IconNames.Happy)\n    })\n    mstate.declareTransition(STATE, \"*\", \"Trigger1\")\n})\ninput.onButtonPressed(Button.A, function () {\n    mstate.start(\"State1\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(\"Trigger1\")\n})\n```\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","mstate.cpp":"#include \"pxt.h\"\n\nnamespace mstate {\n    \n    //%\n    void export_uml(int v, StringData* s) {\n        // only for the simulator\n    }\n\n}","mstate.ts":"enum StateMachines {\r\n    M0 = 0,\r\n    M1,\r\n    M2,\r\n    M3,\r\n    M4,\r\n    M5\r\n}\r\n\r\n/**\r\n * mstate blocks\r\n * Defining blocks: https://makecode.com/defining-blocks\r\n * Playground: https://makecode.com/playground\r\n * icon: a Unicode identifier for an icon from the Font Awesome icon set.\r\n *       http://fontawesome.io/icons\r\n */\r\n//% weight=100 color=\"#4C97FF\" icon=\"\\uf362\"\r\n//% groups=\"['Command', 'Declare', 'Transit']\"\r\nnamespace mstate {\r\n\r\n    const MICROBIT_CUSTOM_ID_BASE = 32768\r\n    const DEFAULT_UPDATE_EVENT_ID = MICROBIT_CUSTOM_ID_BASE + 100\r\n    const DEFAULT_EVENT_LOOP_INTERVAL = 100\r\n\r\n    /**\r\n     * state/trigger id:name\r\n     */\r\n    namespace mname {\r\n        /**\r\n         * id:0 - INITIAL/FINAL/Completion Transition.\r\n         */\r\n        export const NONE_ID = 0   // id:0 - INITIAL/FINAL/Completion Transition\r\n\r\n        /**\r\n         * name:\"\" - INITIAL/FINAL/Completion Transition.\r\n         */\r\n        export const NONE_STR = \"\"\r\n\r\n        /**\r\n         * array of state/trigger name, index is id.\r\n         * default: [NONE_STR,]\r\n         */\r\n        let nameList: string[] = [NONE_STR,]\r\n\r\n        /**\r\n         * get id, new if undefined\r\n         * @param name state name or trigger name\r\n         * @returns state/trigger id\r\n         */\r\n        export function getIdOrNew(name: string) {\r\n            let idx = nameList.indexOf(name)\r\n            if (0 > idx) {\r\n                idx = nameList.length\r\n                nameList.push(name)\r\n            }\r\n            return idx\r\n        }\r\n\r\n        /**\r\n         * get name\r\n         * @param id state/trigger id\r\n         * @returns state/trigger name: \"[<id>]\" if undefined id\r\n         */\r\n        export function getName(id: number) {\r\n            if (0 <= id && nameList.length > id) {\r\n                return nameList[id]\r\n            }\r\n            return \"[\" + id + \"]\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * state machine\r\n     */\r\n    namespace mmachine {\r\n\r\n        /**\r\n         * transition canceled\r\n         */\r\n        const TRANSITION_CANCELED = -1\r\n\r\n        /**\r\n         * Entry/Exit Action\r\n         */\r\n        class EntryExitAction {\r\n\r\n            /**\r\n             * execute Entry.\r\n             */\r\n            execute: () => void\r\n\r\n            /**\r\n             * constructor\r\n             * @param cb code to run\r\n             */\r\n            constructor(cb: () => void) {\r\n                this.execute = cb\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Do Activity\r\n         */\r\n        class DoActivity {\r\n\r\n            // callback\r\n            _cb: () => void\r\n            _ms: number\r\n            _nextTick: number\r\n\r\n            /**\r\n             * constructor\r\n             * @param ms interval (ms)\r\n             * @param cb code to run\r\n             */\r\n            constructor(ms: number, cb: () => void) {\r\n                this._cb = cb\r\n                this._ms = ms\r\n                this._nextTick = -1\r\n            }\r\n\r\n            /**\r\n             * force callback, execute DO\r\n             */\r\n            forceTick() {\r\n                this._nextTick = -1\r\n            }\r\n\r\n            /**\r\n             * execute DO\r\n             * @param tick the number of milliseconds elapsed since power on, control.millis().\r\n             */\r\n            execute(tick: number) {\r\n                if (tick > this._nextTick) {\r\n                    this._cb()\r\n                    this._nextTick = tick + this._ms\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Transition\r\n         */\r\n        class Transition {\r\n            /**\r\n             * array of state id, transition to.\r\n             */\r\n            toList: number[]\r\n            /**\r\n             * trigger id.\r\n             */\r\n            trigger: number\r\n            /**\r\n             * execute Transition.\r\n             * @param triggerArgs trigger args. \r\n             */\r\n            execute: (triggerArgs: number[]) => void\r\n\r\n            /**\r\n             * constructor\r\n             * @param toList array of state id, transition to\r\n             * @param trigger trigger id\r\n             * @param cb run to code, (triggerArgs: number[]) => void\r\n             */\r\n            constructor(toList: number[], trigger: number, cb: (triggerArgs: number[]) => void) {\r\n                this.toList = toList\r\n                this.trigger = trigger\r\n                this.execute = cb\r\n            }\r\n        }\r\n\r\n        class State {\r\n            /**\r\n             * state id.\r\n             */\r\n            state: number\r\n            /**\r\n             * array of entry action\r\n             */\r\n            entryActions: EntryExitAction[]\r\n            /**\r\n             * array of do activity\r\n             */\r\n            doActivities: DoActivity[]\r\n            /**\r\n             * array of exit action\r\n             */\r\n            exitActions: EntryExitAction[]\r\n            /**\r\n             * array of transition\r\n             */\r\n            transitions: Transition[]\r\n\r\n            constructor(state: number) {\r\n                this.state = state\r\n                this.entryActions = []\r\n                this.doActivities = []\r\n                this.exitActions = []\r\n                this.transitions = []\r\n            }\r\n        }\r\n\r\n        /**\r\n         * trigger and args\r\n         */\r\n        class TriggerWithArgs {\r\n            /**\r\n             * trigger id.\r\n             */\r\n            trigger: number\r\n            /**\r\n             * trigger args.\r\n             */\r\n            args: number[]\r\n\r\n            /**\r\n             * constructor\r\n             * @param trigger trigger id\r\n             * @param args trigger args\r\n             */\r\n            constructor(trigger: number, args: number[]) {\r\n                this.trigger = trigger\r\n                this.args = args\r\n            }\r\n        }\r\n\r\n        enum ProcState {\r\n            Panic,\r\n            Idle,\r\n            Start,\r\n            Into,\r\n            Enter,\r\n            Do,\r\n            CompletionTransit,\r\n            Pause,\r\n            TriggeredTransit,\r\n            Exit\r\n        }\r\n\r\n        enum ProcNextBehavior {\r\n            Break,\r\n            Loop,\r\n            Event\r\n        }\r\n\r\n        class StateMachine {\r\n\r\n            /**\r\n             * machine id\r\n             */\r\n            machine: number\r\n\r\n            // system\r\n            _initialized: boolean\r\n            _updateEventId: number\r\n            _eventLoopInterval: number\r\n            _enabledUpdateEvent: boolean\r\n\r\n            /**\r\n             * next proc\r\n             */\r\n            _procNext: ProcState\r\n\r\n            /**\r\n             * default state id for start.\r\n             */\r\n            _defaultState: number\r\n\r\n            /**\r\n             * array of state.\r\n             */\r\n            _states: State[]\r\n\r\n            /**\r\n             * current state\r\n             */\r\n            _state: State\r\n\r\n            /**\r\n             * trigger queue, array of TriggerWithArgs.\r\n             */\r\n            _triggerQueue: TriggerWithArgs[]\r\n\r\n            // selectable taransition\r\n            _selectedToAt: number   // >=0: selected, TRANSITION_CANCELED: unselected\r\n\r\n            // current transition\r\n            _transitTo: number\r\n\r\n            // reset on into.\r\n            _timeoutMillis: number\r\n\r\n            /**\r\n             * constructor\r\n             * The state machine ID is used as the event value, so it must be greater than 0\r\n             * @param machine state machine ID (>0)\r\n             */\r\n            constructor(machine: number) {\r\n                this.machine = machine\r\n                // system\r\n                this._initialized = false\r\n                this._updateEventId = DEFAULT_UPDATE_EVENT_ID\r\n                this._eventLoopInterval = DEFAULT_EVENT_LOOP_INTERVAL\r\n                this._enabledUpdateEvent = false\r\n                this._defaultState = mname.NONE_ID\r\n\r\n                this._states = []\r\n\r\n                // current\r\n                this._state = undefined\r\n\r\n                // (Triggers[]) triggers\r\n                this._triggerQueue = []\r\n\r\n                // current transition\r\n                this._transitTo = TRANSITION_CANCELED\r\n\r\n                // selectable taransition\r\n                this._selectedToAt = TRANSITION_CANCELED\r\n\r\n                // proc\r\n                this._procNext = ProcState.Idle\r\n\r\n            }\r\n\r\n            /**\r\n             * get State instance, or new.\r\n             * @param stete state id\r\n             * @returns instance of State, undefined if NONE_ID. \r\n             */\r\n            _getStateOrNew(state: number) {\r\n                if (mname.NONE_ID < state) {\r\n                    const obj = this._states.find(item => state == item.state)\r\n                    if (undefined !== obj) {\r\n                        return obj\r\n                    }\r\n                    const newObj = new State(state)\r\n                    this._states.push(newObj)\r\n                    return newObj\r\n                }\r\n                return undefined\r\n            }\r\n\r\n            declareEntry(state: number, cb: () => void) {\r\n                const objState = this._getStateOrNew(state)\r\n                objState.entryActions.push(new EntryExitAction(cb))\r\n            }\r\n\r\n            declareDo(state: number, ms: number, cb: () => void) {\r\n                const objState = this._getStateOrNew(state)\r\n                objState.doActivities.push(new DoActivity(ms, cb))\r\n            }\r\n\r\n            declareExit(state: number, cb: () => void) {\r\n                const objState = this._getStateOrNew(state)\r\n                objState.exitActions.push(new EntryExitAction(cb))\r\n            }\r\n\r\n            declareTransition(state: number, trigger: number, toList: number[], cb: (triggerArgs: number[]) => void) {\r\n                const objState = this._getStateOrNew(state)\r\n                objState.transitions.push(new Transition(toList, trigger, cb))\r\n            }\r\n\r\n            _procStart() {\r\n                this._transitTo = this._defaultState\r\n            }\r\n\r\n            _procInto() {\r\n                this._state = this._getStateOrNew(this._transitTo)\r\n                this._timeoutMillis = control.millis()\r\n                return undefined !== this._state\r\n            }\r\n\r\n            _procEnter() {\r\n                for (const v of this._state.entryActions) {\r\n                    v.execute()\r\n                }\r\n            }\r\n\r\n            _procDo() {\r\n                const tick = control.millis()\r\n                for (const v of this._state.doActivities) {\r\n                    v.execute(tick)\r\n                }\r\n            }\r\n\r\n            _procExit() {\r\n                for (const v of this._state.exitActions) {\r\n                    v.execute()\r\n                }\r\n            }\r\n\r\n            _doCallbackSelectable(transition: Transition, triggerArgs: number[]) {\r\n                this._selectedToAt = TRANSITION_CANCELED    // reset\r\n                transition.execute(triggerArgs)             // callback\r\n                if (0 <= this._selectedToAt && transition.toList.length > this._selectedToAt) {\r\n                    // selected\r\n                    this._transitTo = transition.toList[this._selectedToAt]\r\n                    return true\r\n                }\r\n                return false\r\n            }\r\n\r\n            // Completion Transition\r\n            _procCompletionTransition() {\r\n                const emptyArgs: number[] = []\r\n                const transitions = this._state.transitions.filter(item => mname.NONE_ID == item.trigger)\r\n                for (const transition of transitions) {\r\n                    if (this._doCallbackSelectable(transition, emptyArgs)) {\r\n                        return true\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n\r\n            // Triggered Transition\r\n            _procTriggeredTransition() {\r\n                while (0 < this._triggerQueue.length) {\r\n                    const triggerAndArgs = this._triggerQueue.shift()\r\n                    const transitions = this._state.transitions.filter(item => triggerAndArgs.trigger == item.trigger)\r\n                    for (const transition of transitions) {\r\n                        if (this._doCallbackSelectable(transition, triggerAndArgs.args)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n\r\n            _proc(): ProcNextBehavior {\r\n                let ret = ProcNextBehavior.Loop // (default) loop\r\n                switch (this._procNext) {\r\n                    case ProcState.Idle:\r\n                        ret = ProcNextBehavior.Break    // break\r\n                        break;\r\n                    case ProcState.Start:\r\n                        this._procStart()\r\n                        this._procNext = ProcState.Into\r\n                        ret = ProcNextBehavior.Event    // event, for start() function.\r\n                        break;\r\n                    case ProcState.Into:\r\n                        if (this._procInto()) {\r\n                            this._procNext = ProcState.Enter\r\n                        } else {\r\n                            // (INITIAL or FINAL)\r\n                            this._procNext = ProcState.Idle\r\n                        }\r\n                        break;\r\n                    case ProcState.Enter:\r\n                        this._procEnter()\r\n                        this._procNext = ProcState.Do\r\n                        break;\r\n                    case ProcState.Do:\r\n                        this._procDo()\r\n                        this._procNext = ProcState.CompletionTransit\r\n                        break;\r\n                    case ProcState.CompletionTransit:\r\n                        if (this._procCompletionTransition()) {\r\n                            this._procNext = ProcState.Exit\r\n                        } else {\r\n                            this._procNext = ProcState.Pause\r\n                            ret = ProcNextBehavior.Event    // event\r\n                        }\r\n                        break;\r\n                    case ProcState.Pause:\r\n                        this._procNext = ProcState.TriggeredTransit\r\n                        break;\r\n                    case ProcState.TriggeredTransit:\r\n                        if (this._procTriggeredTransition()) {\r\n                            this._procNext = ProcState.Exit\r\n                        } else {\r\n                            this._procNext = ProcState.Do\r\n                        }\r\n                        break;\r\n                    case ProcState.Exit:\r\n                        this._procExit()\r\n                        this._procNext = ProcState.Into\r\n                        break;\r\n                    case ProcState.Panic:\r\n                    default:\r\n                        // panic\r\n                        this._procNext = ProcState.Panic\r\n                        ret = ProcNextBehavior.Break    // break\r\n                        break;\r\n                }\r\n                return ret\r\n            }\r\n\r\n            _update() {\r\n                let next: ProcNextBehavior\r\n                do {\r\n                    next = this._proc()\r\n                } while (ProcNextBehavior.Loop == next)\r\n                this._enabledUpdateEvent = (ProcNextBehavior.Event == next)\r\n            }\r\n\r\n            _raiseUpdateEvent(force: boolean = false) {\r\n                if (force || this._enabledUpdateEvent) {\r\n                    control.raiseEvent(this._updateEventId, this.machine)\r\n                }\r\n            }\r\n\r\n            _initialize() {\r\n                if (!this._initialized) {\r\n                    this._initialized = true\r\n                    const that: StateMachine = this\r\n                    // update event handler\r\n                    const updateEventId = this._updateEventId\r\n                    const machineId = this.machine\r\n                    control.onEvent(updateEventId, machineId, function () {\r\n                        that._update()\r\n                    })\r\n                    // update event loop\r\n                    const eventLoopInterval = this._eventLoopInterval\r\n                    loops.everyInterval(eventLoopInterval, function () {\r\n                        that._raiseUpdateEvent()\r\n                    })\r\n                }\r\n            }\r\n\r\n            start(state: number): boolean {\r\n                this._initialize()\r\n                if (ProcState.Idle == this._procNext) {\r\n                    this._defaultState = state\r\n                    this._procNext = ProcState.Start\r\n                    this._update()\r\n                    return true\r\n                } else {\r\n                    return false\r\n                }\r\n            }\r\n\r\n            fire(trigger: number, args: number[]) {\r\n                if ((ProcState.Idle != this._procNext) && (ProcState.Panic != this._procNext)) {\r\n                    // queuing\r\n                    const triggerArgs = new TriggerWithArgs(trigger, args)\r\n                    this._triggerQueue.push(triggerArgs)\r\n                    // update event\r\n                    this._raiseUpdateEvent(true)\r\n                }\r\n            }\r\n\r\n            selectToAt(index: number) {\r\n                this._selectedToAt = index\r\n            }\r\n\r\n            timeouted(ms: number) {\r\n                return control.millis() > this._timeoutMillis + ms\r\n            }\r\n        }\r\n\r\n        // state machine\r\n        let stateMachineList: StateMachine[] = []\r\n\r\n        export function getStateMachine(machine: StateMachines) {\r\n            const obj = stateMachineList.find(item => machine == item.machine)\r\n            if (obj) {\r\n                return obj\r\n            }\r\n            const newObj = new StateMachine(machine)\r\n            stateMachineList.push(newObj)\r\n            return newObj\r\n        }\r\n    }\r\n\r\n    /**\r\n     * convert state/trigger name (string) to id (number): new id if undefined\r\n     * @param name state name (string) or trigger name (string)\r\n     * @returns state id or trigger id\r\n     */\r\n    //% block=\"id of $name\"\r\n    //% name.defl=\"a\"\r\n    //% weight=210\r\n    export function convId(name: string): number {\r\n        return mname.getIdOrNew(name)\r\n    }\r\n\r\n    /**\r\n     * convert id (number) to state/trigger name (string)\r\n     * @param id state id or trigger id\r\n     * @returns state name (string) or trigger name (string): \"[<id>]\" if undefined\r\n     */\r\n    //% block=\"name of $id\"\r\n    //% weight=200\r\n    export function convName(id: number): string {\r\n        return mname.getName(id)\r\n    }\r\n\r\n    /**\r\n     * define state\r\n     * @param aStateMachine StateMachines\r\n     * @param aStateName state name\r\n     * @param body code to run, (machine: machine ID, state: state ID)\r\n     */\r\n    //% block=\"define [$machine,$state] to $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=Machines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% draggableParameters=\"reporter\"\r\n    //% weight=180\r\n    //% group=\"Declare\"\r\n    export function defineState(aStateMachine: StateMachines, aStateName: string,\r\n        body: (machine: number, state: number) => void\r\n    ) {\r\n        body(aStateMachine, convId(aStateName))\r\n    }\r\n\r\n    /**\r\n     * declare ENTRY action.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on entry [$aMachine,$aState]\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% handlerStatement\r\n    //% weight=170\r\n    //% group=\"Declare\"\r\n    export function declareEntry(aMachine: number, aState: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).declareEntry(aState, body)\r\n    }\r\n\r\n    /**\r\n     * declare DO activity.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aEvery interval time (milliseconds)\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on do [$aMachine,$aState] every $aEvery ms\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aEvery.shadow=\"timePicker\"\r\n    //% handlerStatement\r\n    //% weight=160\r\n    //% group=\"Declare\"\r\n    export function declareDo(aMachine: number, aState: number, aEvery: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).declareDo(aState, aEvery, body)\r\n    }\r\n\r\n    /**\r\n     * declare EXIT action.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on exit [$aMachine,$aState]\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% handlerStatement\r\n    //% weight=150\r\n    //% group=\"Declare\"\r\n    export function declareExit(aMachine: number, aState: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).declareExit(aState, body)\r\n    }\r\n\r\n    /**\r\n     * declare simple transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aTriggerName trigger name\r\n     * @param aToName next state nam\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] when $aTriggerName to $aToName\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% aToName.defl=\"a\"\r\n    //% inlineInputMode=inline\r\n    //% weight=140\r\n    //% group=\"Transition\"\r\n    export function declareSimpleTransition(aMachine: number, aState: number, aTriggerName: string, aToName: string) {\r\n        declareCustomTransition(aMachine, aState, aTriggerName, [aToName], function (args) {\r\n            mstate.transitTo(aMachine, 0)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * declare timeouted transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aMs timeout (ms)\r\n     * @param aToName next state name\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] timeouted $aMs to $aToName\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aMs.shadow=\"timePicker\"\r\n    //% aToName.defl=\"a\"\r\n    //% inlineInputMode=inline\r\n    //% weight=130\r\n    //% group=\"Transition\"\r\n    export function declareTimeoutedTransition(aMachine: number, aState: number, aMs: number, aToName: string) {\r\n        declareCustomTransition(aMachine, aState, \"\", [aToName], function (args) {\r\n            if (mstate.isTimeouted(aMachine, aMs)) {\r\n                mstate.transitTo(aMachine, 0)\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * declare custom transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aTriggerName trigger name\r\n     * @param aTransList array of next state name \r\n     * @param body code to run\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] when $aTriggerName $args to $aTransList\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% draggableParameters=\"reporter\"\r\n    //% handlerStatement\r\n    //% weight=120\r\n    //% group=\"Transition\"\r\n    export function declareCustomTransition(aMachine: number, aState: number, aTriggerName: string, aTransList: string[],\r\n        body: (args: number[]) => void\r\n    ) {\r\n        const trigger = convId(aTriggerName)\r\n        let toList: number[] = []\r\n        for (const s of aTransList) {\r\n            toList.push(convId(s))\r\n        }\r\n        mmachine.getStateMachine(aMachine).declareTransition(aState, trigger, toList, body)\r\n    }\r\n\r\n    /**\r\n     * is timeouted.\r\n     * @param aMachine machine ID\r\n     * @param aMs timeout (milliseconds)\r\n     */\r\n    //% block=\"timeouted [$aMachine] $aMs\"\r\n    //% aMachine.defl=0\r\n    //% aMs.shadow=\"timePicker\"\r\n    //% weight=110\r\n    //% group=\"Transition\"\r\n    export function isTimeouted(aMachine: number, aMs: number): boolean {\r\n        return mmachine.getStateMachine(aMachine).timeouted(aMs)\r\n    }\r\n\r\n    /**\r\n     * transit to.\r\n     * @param aMachine machine ID\r\n     * @param index states index]\r\n     */\r\n    //% block=\"transit [$aMachine] at $index\"\r\n    //% aMachine.defl=0\r\n    //% index.defl=0\r\n    //% weight=100\r\n    //% group=\"Transition\"\r\n    export function transitTo(aMachine: number, index: number) {\r\n        mmachine.getStateMachine(aMachine).selectToAt(index)\r\n    }\r\n\r\n    /**\r\n     * fire trigger\r\n     * @param aStateMachine StateMachines\r\n     * @param aTriggerName trigger name\r\n     * @param aTriggerArgs args\r\n     */\r\n    //% block=\"fire $aStateMachine $aTriggerName $aTriggerArgs\"\r\n    //% aStateMachine.defl=Machines.M0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% weight=90\r\n    //% group=\"Command\"\r\n    export function fire(aStateMachine: StateMachines, aTriggerName: string, aTriggerArgs: number[]) {\r\n        mmachine.getStateMachine(aStateMachine).fire(convId(aTriggerName), aTriggerArgs)\r\n    }\r\n\r\n    /**\r\n     * start state machine\r\n     * @param aStateMachine StateMachines\r\n     * @param aStateName default state name\r\n     */\r\n    //% block=\"start $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=Machines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% weight=80\r\n    //% group=\"Command\"\r\n    export function start(aStateMachine: StateMachines, aStateName: string) {\r\n        mmachine.getStateMachine(aStateMachine).start(convId(aStateName))\r\n    }\r\n\r\n    /**\r\n     * export UML, PlantUML\r\n     * PlantUML Web server: http://www.plantuml.com/plantuml/\r\n     * @param aStateMachine\r\n     * @param aStateName default state\r\n     */\r\n    //% block=\"UML $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=Machines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% weight=70\r\n    //% group=\"Command\"\r\n    //% shim=mstate::export_uml\r\n    export function exportUml(aStateMachine: StateMachines, aStateName: string) {\r\n        // for the simulator\r\n        const cb = console.log\r\n        cb(\"@startuml\")\r\n        //cb(\"' PlantUML Web server:\")\r\n        cb(\"' http://www.plantuml.com/plantuml/\")\r\n        // top state - machine name\r\n        cb(\"state __M\" + aStateMachine + \"__ {\")\r\n\r\n        // start\r\n        cb(\"[*] --> \" + aStateName)\r\n\r\n        // target machine\r\n        const target = mmachine.getStateMachine(aStateMachine)\r\n        for (const state of target._states) {\r\n            // state\r\n            cb(\"state \" + mstate.convName(state.state))\r\n            for (const trans of state.transitions) {\r\n                // transition\r\n                const desc = mstate.convName(trans.trigger)\r\n                for (const to_ of trans.toList) {\r\n                    cb(mstate.convName(state.state) + \" --> \" + (mname.NONE_ID == to_ ? \"[*]\" : mstate.convName(to_)) + (\"\" == desc ? \"\" : \" : \" + desc))\r\n                }\r\n            }\r\n        }\r\n\r\n        cb(\"}\") // top state - machine name\r\n        cb(\"@enduml\")\r\n    }\r\n}\r\n","pxt.json":"{\n    \"name\": \"pxt-mstate\",\n    \"version\": \"0.5.2\",\n    \"description\": \"Let's try state machine with micro:bit!\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"mstate.cpp\",\n        \"mstate.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.17\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\n\n// blink\nfunction blinkLED() {\n    if (0 == blinkNext) {\n        blinkNext = 1\n        led.setBrightness(100)\n    } else {\n        blinkNext = 0\n        led.setBrightness(255)\n    }\n}\n\n// State Off\n// entry/\n// - LED off\nmstate.defineState(StateMachines.M0, \"Off\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        mode = 0\n        basic.clearScreen()\n    })\n    mstate.declareExit(machine, state, function () {\n        led.setBrightness(255)\n        basic.showString(\"Power!\")\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"On\")\n})\n\n// Stete On\n// entry/\n// - Initialize On/Blink\n// - LED Heart\nmstate.defineState(StateMachines.M0, \"On\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        mode = 0\n        led.setBrightness(255)\n        blinkNext = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"Slow\")\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off\")\n    mstate.declareSimpleTransition(machine, state, \"Auto\", \"Slow\")\n})\n\n// State Slow\n// entry/\n// - reset blinkCount\n// do/ (500ms)\n// - LED blink\n// [Auto Mode] 6times\nmstate.defineState(StateMachines.M0, \"Slow\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        blinkCount = 0\n    })\n    mstate.declareDo(machine, state, 500, function () {\n        blinkCount += 1\n        if (1 == mode && 6 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareCustomTransition(machine, state, \"\", [\"Fast\"], function (args) {\n        if (0 > blinkCount) {\n            mstate.transitTo(machine, 0)\n        }\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"Fast\")\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off\")\n})\n\n// State Fast\n// entry/\n// - reset blinkCount\n// do/ (200ms)\n// - LED blink\n// [Auto Mode] 16times\nmstate.defineState(StateMachines.M0, \"Fast\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        blinkCount = 0\n    })\n    mstate.declareDo(machine, state, 200, function () {\n        blinkCount += 1\n        if (1 == mode && 15 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareCustomTransition(machine, state, \"\", [\"Slow\"], function (args) {\n        if (0 > blinkCount) {\n            mstate.transitTo(machine, 0)\n        }\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"On\")\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off\")\n    mstate.declareTimeoutedTransition(machine, state, 5000, \"On\")\n})\n\ninput.onButtonPressed(Button.A, function () {\n    mstate.fire(StateMachines.M0, \"A\", [])\n})\ninput.onButtonPressed(Button.AB, function () {\n    mstate.fire(StateMachines.M0, \"Auto\", [])\n    mode = 1\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(StateMachines.M0, \"B\", [])\n})\nlet blinkCount = 0\nlet mode = 0\nlet blinkNext = 0\nmstate.start(StateMachines.M0, \"Off\")\n"}