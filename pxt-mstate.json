{"README.md":"\n> Open this page at GitHub Pages: [https://jp-rad.github.io/pxt-mstate/](https://jp-rad.github.io/pxt-mstate/)\n\n## Creating Extensions\n\nExtensions are PXTâ€™s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\n\n* [MakeCode extensions](https://makecode.com/extensions)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-rad/pxt-mstate** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-rad/pxt-mstate/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-rad/pxt-mstate** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/statics/blocks.png)\n\n\n**Example**\n\n```javascript\nlet blink = 0\nfunction blinkLED () {\n    led.setBrightness(blink * 155 + 100)\n    blink += 1\n    blink = blink % 2\n}\nmstate.defineStateName(\"State1\", function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        blink = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareDo(STATE, 500, function () {\n        blinkLED()\n    })\n    mstate.declareExit(STATE, function (next) {\n        led.setBrightness(255)\n        basic.showIcon(IconNames.Happy)\n    })\n    mstate.declareTransition(STATE, \"*\", \"Trigger1\")\n})\ninput.onButtonPressed(Button.A, function () {\n    mstate.start(\"State1\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(\"Trigger1\")\n})\n```\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","mstate.ts":"/**\n * mstate blocks\n */\n//% weight=100 color=\"#4C97FF\" icon=\"\\uf362\"\n//% groups=\"['Action', 'Command', 'Declare', 'Design', 'Transition']\"\nnamespace mstate {\n\n    const CHAR_ASTERISK = \"*\"       // asterisk charactor \"*\"\n    const STATE_INITIAL_FINAL = -1  // \"*\"(INITIAL or FINAL)\n    const TRIGGER_NONE = 0          // \"\"(completion)\n    const NUMERIC_NAN = -1          // missing value, number\n\n    const MICROBIT_CUSTOM_ID_BASE = 32768\n    const DEFAULT_UPDATE_EVENT_ID = MICROBIT_CUSTOM_ID_BASE + 100\n    const DEFAULT_EVENT_LOOP_INTERVAL = 100\n\n    const DEFAULT_STATE_MACHINE_NAME = \"default\"\n\n    const CHAR_GUARD = \"?\"  // [<guard>?]<state name>\n\n    /**\n     * EntryAction\n     */\n    class EntryAction {\n        _state: number\n        _cb: (prev: number) => void\n\n        /**\n         * constructor\n         * @param state (States) state\n         * @param cb code to run\n         */\n        constructor(state: number, cb: (prev: number) => void) {\n            this._state = state\n            this._cb = cb\n        }\n\n        /**\n         * (States) state\n         */\n        get state() { return this._state }\n\n        /**\n         * execute ENTRY\n         * @param prev (States) previous state\n         */\n        execute(prev: number) { this._cb(prev) }\n    }\n\n    /**\n     * DoActivity\n     */\n    class DoActivity {\n        // declare\n        _state: number\n        _ms: number\n        _cb: () => void\n\n        // callback tick\n        _lastTick: number\n        _nextTick: number\n        _forceTick: boolean\n\n        /**\n         * constructor\n         * @param state (States) state\n         * @param ms interval (ms)\n         * @param cb code to run\n         */\n        constructor(state: number, ms: number, cb: () => void) {\n            this._state = state\n            this._ms = ms\n            this._cb = cb\n            this._lastTick = control.millis()\n            this._nextTick = this._lastTick\n            this._forceTick = true\n        }\n\n        /**\n         * (States) state\n         */\n        get state() { return this._state }\n\n        /**\n         * execute DO\n         * @param tick the number of milliseconds elapsed since power on, control.millis().\n         */\n        execute(tick: number) {\n            if (this._forceTick || (tick > this._nextTick)) {\n                this._cb()\n                this._forceTick = false\n                this._lastTick = tick\n                this._nextTick = tick + this._ms\n            }\n        }\n\n        /**\n         * force callback, execute DO\n         */\n        forceTick() {\n            this._forceTick = true\n        }\n    }\n\n    /**\n     * ExitAction\n     */\n    class ExitAction {\n        // declare\n        _state: number\n        _cb: (next: number) => void\n\n        /**\n         * constructor\n         * @param state (States) state\n         * @param cb code to run\n         */\n        constructor(state: number, cb: (next: number) => void) {\n            this._state = state\n            this._cb = cb\n        }\n\n        /**\n         * (States) state\n         */\n        get state() { return this._state }\n\n        /**\n         * execute EXIT\n         * @param next (States) next state\n         */\n        execute(next: number) { this._cb(next) }\n    }\n\n    /**\n     * Transition timeout\n     */\n    class TransitionTimeout {\n        // declare\n        _from: number\n        _to: number\n        _timeout: number\n        _asArrow: boolean\n\n        /**\n         * constructor\n         * @param from (States) state, transition from\n         * @param to (States) state, transition to\n         * @param timeout timeout (ms)\n         * @param asArrow display as arrows in diagrams, UML\n         */\n        constructor(from: number, to: number, timeout: number, asArrow: boolean) {\n            this._from = from\n            this._to = to\n            this._timeout = timeout\n            this._asArrow = asArrow\n        }\n\n        /**\n         * (States) state, transition from\n         */\n        get from() { return this._from }\n\n        /**\n         * (States) state, transition to\n         */\n        get to() { return this._to }\n\n        /**\n         *  timeout (ms)\n         */\n        get timeout() { return this._timeout }\n\n        /**\n         * display as arrows in diagrams, UML\n         */\n        get asArrow() { return this._asArrow }\n    }\n\n    /**\n     * Transition\n     */\n    class Transition {\n        // declare\n        _from: number\n        _to: number\n        _trigger: number\n\n        /**\n         * constructor\n         * @param from (States) state, transition from\n         * @param to (States) state, transition to\n         * @param trigger (Triggers) trigger\n         */\n        constructor(from: number, to: number, trigger: number) {\n            this._from = from\n            this._to = to\n            this._trigger = trigger\n        }\n\n        /**\n         * (States) state, transition from\n         */\n        get from() { return this._from }\n\n        /**\n         * (States) state, transition to\n         */\n        get to() { return this._to }\n\n        /**\n         * (Triggers) trigger\n         */\n        get trigger() { return this._trigger }\n    }\n\n    /**\n     * Selectable transition\n     */\n    class TransitionSelectable {\n        // declare\n        _from: number\n        _toList: number[]\n        _trigger: number\n        _cb: () => void\n        _guardList: string[]\n\n        /**\n         * constructor\n         * @param from (States) state, transition from\n         * @param toList (States) selectabale states, arrray of transition to\n         * @param trigger (Triggers) trigger\n         * @param cb run to code for selecting state, transition to\n         */\n        constructor(from: number, toList: number[], trigger: number, cb: () => void, guardList: string[]) {\n            this._from = from\n            this._toList = toList\n            this._trigger = trigger\n            this._cb = cb\n            this._guardList = []\n            for (let i = 0; i < toList.length; i++) {\n                const guard = guardList[i]\n                this._guardList.push(guard)\n            }\n        }\n\n        /**\n         * (States) state, transition from\n         */\n        get from() { return this._from }\n\n        /**\n         * (States) selectabale states, arrray of transition to\n         */\n        get toList() { return this._toList }\n\n        /**\n         * (Triggers) trigger\n         */\n        get trigger() { return this._trigger }\n\n        /**\n         * Callback to select state, transition to\n         */\n        cb() {\n            this._cb()\n        }\n    }\n\n    /**\n     * Trigger and user's args\n     */\n    class TriggerArgs {\n        // trigger and args\n        _trigger: number\n        _args: number[]\n\n        /**\n         * constructor\n         * @param trigger trigger\n         * @param args args for user\n         */\n        constructor(trigger: number, args: number[]) {\n            this._trigger = trigger\n            this._args = args\n        }\n\n        /**\n         * trigger\n         */\n        get trigger() { return this._trigger }\n\n        /**\n         * args for user\n         */\n        get args() { return this._args }\n    }\n\n    class StateDescription {\n        _state: number\n        _description: string\n\n        constructor(state: number, description: string) {\n            this._state = state\n            this._description = description\n        }\n\n        get state() { return this._state }\n        get description() { return this._description }\n    }\n\n    enum ProcStatus {\n        Idle,\n        Start,\n        Into,\n        Enter,\n        Do,\n        Exit,\n        Transit,\n        Panic\n    }\n\n    enum ProcNextBehavior {\n        Break,\n        Loop,\n        Event\n    }\n\n    class StateMachine {\n\n        // system\n        _machineId: number\n        _macnineName: string\n        _initialized: boolean\n        _updateEventId: number\n        _eventLoopInterval: number\n        _enabledUpdateEvent: boolean\n        _defaultState: number           // start\n\n        // declare\n        _declareEntryActions: EntryAction[]\n        _declareDoActivities: DoActivity[]\n        _declareExitActions: ExitAction[]\n        _declareTransitions: Transition[]\n        _declareTransitionSelectables: TransitionSelectable[]\n        _declareTransitionTImeouts: TransitionTimeout[]         // Less than one per state, the one with the minimum timeout.\n\n        // current\n        _state: number\n        _entryActions: EntryAction[]\n        _doActivities: DoActivity[]\n        _exitActions: ExitAction[]\n        _trasitionTimeout: TransitionTimeout                        // Priority - 1: Highest (timeouted)\n        _transitionSelectables: TransitionSelectable[]              // Priority - 2: High\n        _transitions: Transition[]                                  // Priority - 3: Middle (High)\n        _completionTransitionSelectables: TransitionSelectable[]    // Priority - 4: Middle (Low)\n        _completionTransition: Transition                           // Priority - 5: Low\n\n        // proc\n        _procNext: ProcStatus\n\n        // timeout transition\n        _timeoutMillis: number\n\n        // (Triggers[]) triggers\n        _triggerQueue: TriggerArgs[]\n\n        // current transition\n        _transitFrom: number\n        _transitTo: number\n        _argsOfTrigger: number[]\n\n        // selectable taransition\n        _selectedToAt: number   // >=0: selected, NUMERIC_NAN: unselected\n        _selectedTo: number     // TODO: deprecated\n\n        // design\n        _stateDescriptions: StateDescription[]\n\n        /**\n         * constructor\n         * The state machine ID is used as the event value, so it must be greater than 0\n         * @param id state machine ID (>0)\n         * @param name state machine name\n         */\n        constructor(id: number, name: string) {\n            // system\n            this._machineId = id\n            this._macnineName = name\n            this._initialized = false\n            this._updateEventId = DEFAULT_UPDATE_EVENT_ID\n            this._eventLoopInterval = DEFAULT_EVENT_LOOP_INTERVAL\n            this._enabledUpdateEvent = false\n            this._defaultState = STATE_INITIAL_FINAL\n\n            // declare\n            this._declareEntryActions = []\n            this._declareDoActivities = []\n            this._declareExitActions = []\n            this._declareTransitionTImeouts = []\n            this._declareTransitions = []\n            this._declareTransitionSelectables = []\n\n            // current\n            this._state = STATE_INITIAL_FINAL\n            this._entryActions = []\n            this._doActivities = []\n            this._exitActions = []\n            this._trasitionTimeout = undefined\n            this._transitionSelectables = []\n            this._transitions = []\n            this._completionTransitionSelectables = []\n            this._completionTransition = undefined\n\n            // proc\n            this._procNext = ProcStatus.Idle\n\n            // timeout transition\n            this._timeoutMillis = NUMERIC_NAN\n\n            // (Triggers[]) triggers\n            this._triggerQueue = []\n\n            // current transition\n            this._transitFrom = STATE_INITIAL_FINAL\n            this._transitTo = STATE_INITIAL_FINAL\n            this._argsOfTrigger = []\n\n            // selectable taransition\n            this._selectedToAt = NUMERIC_NAN\n            this._selectedTo = NUMERIC_NAN\n\n            // design\n            this._stateDescriptions = []\n        }\n\n        get machineId() { return this._machineId }\n\n        get machineName() { return this._macnineName }\n\n        declareEntry(state: number, cb: (prev: number) => void) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new EntryAction(state, cb)\n                this._declareEntryActions.push(item)\n            }\n        }\n\n        declareDo(state: number, ms: number, cb: () => void) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new DoActivity(state, ms, cb)\n                this._declareDoActivities.push(item)\n            }\n        }\n\n        declareExit(state: number, cb: (next: number) => void) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new ExitAction(state, cb)\n                this._declareExitActions.push(item)\n            }\n        }\n\n        declareTransitionTimeout(from: number, to: number, timeout: number, asArrow: boolean) {\n            if (ProcStatus.Idle == this._procNext) {\n                const found = this._declareTransitionTImeouts.find((item) => from == item.from)\n                if (undefined == found) {\n                    const item = new TransitionTimeout(from, to, timeout, asArrow)\n                    this._declareTransitionTImeouts.push(item)\n                }\n            }\n        }\n\n        declareTransition(from: number, to: number, trigger: number) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new Transition(from, to, trigger)\n                this._declareTransitions.push(item)\n            }\n        }\n\n        declareTransitionSelectable(from: number, toList: number[], trigger: number, cb: () => void, guardList: string[]) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new TransitionSelectable(from, toList, trigger, cb, guardList)\n                this._declareTransitionSelectables.push(item)\n            }\n        }\n\n        addStateDescription(state: number, description: string) {\n            if (ProcStatus.Idle == this._procNext) {\n                const item = new StateDescription(state, description)\n                this._stateDescriptions.push(item)\n            }\n        }\n\n        _procStart() {\n            this._transitFrom = STATE_INITIAL_FINAL\n            this._transitTo = this._defaultState\n        }\n\n        _procInto() {\n            const next = this._transitTo\n            // into current\n            this._state = next\n            this._entryActions = this._declareEntryActions.filter((item) => next == item.state)\n            this._doActivities = this._declareDoActivities.filter((item) => {\n                if (next == item.state) {\n                    item.forceTick()\n                    return true\n                } else {\n                    return false\n                }\n            })\n            this._exitActions = this._declareExitActions.filter((item) => next == item.state)\n            this._trasitionTimeout = this._declareTransitionTImeouts.find((item) => next == item.from)\n            // reset timeout\n            if (this._trasitionTimeout) {\n                this.resetTimeout(this._trasitionTimeout.timeout)\n            } else {\n                this.resetTimeout(NUMERIC_NAN)\n            }\n            this._transitions = this._declareTransitions.filter((item) => next == item.from)\n            this._transitionSelectables = this._declareTransitionSelectables.filter((item) => next == item.from)\n            this._completionTransitionSelectables = this._transitionSelectables.filter((item) => TRIGGER_NONE == item.trigger)\n            this._completionTransition = this._transitions.find((item) => TRIGGER_NONE == item.trigger)\n        }\n\n        _procEnter() {\n            const prev = this._transitFrom\n            for (const entryProc of this._entryActions) {\n                entryProc.execute(prev)\n            }\n        }\n\n        _procDo() {\n            const tick = control.millis()\n            for (const doProc of this._doActivities) {\n                doProc.execute(tick)\n            }\n        }\n\n        _procExit() {\n            const next = this._transitTo\n            for (const exitProc of this._exitActions) {\n                exitProc.execute(next)\n            }\n        }\n\n        _doCallbackSelectable(transition: TransitionSelectable) {\n            if (transition) {\n                this._selectedToAt = NUMERIC_NAN    // reset\n                this._selectedTo = NUMERIC_NAN      // reset\n                transition.cb()                     // callback\n                if (0 <= this._selectedToAt && transition.toList.length > this._selectedToAt) {\n                    // selected\n                    this._transitFrom = transition.from\n                    this._transitTo = transition.toList[this._selectedToAt]\n                    return true\n                }\n                if (0 <= this._selectedTo) {\n                    const selectedTo = transition.toList.find((v) => v == this._selectedTo)\n                    if (selectedTo) {\n                        // selected\n                        this._transitFrom = transition.from\n                        this._transitTo = selectedTo\n                        return true\n                    }\n                }\n            }\n            return false\n        }\n\n        _procTransit(): boolean {\n            // Timeout Transition\n            this._argsOfTrigger = undefined\n            if (this._trasitionTimeout && this.timeouted()) {\n                const transition = this._trasitionTimeout\n                this._transitFrom = transition.from\n                this._transitTo = transition.to\n                return true\n            }\n            // triggers - Transition and/or Transition (selectable)\n            while (0 < this._triggerQueue.length) {\n                const trigger = this._triggerQueue.shift()\n                this._argsOfTrigger = trigger.args\n                // Transition (selectable)\n                if (0 < this._transitionSelectables.length) {\n                    const transition = this._transitionSelectables.find((item) => trigger.trigger == item.trigger)\n                    if (this._doCallbackSelectable(transition)) {\n                        return true\n                    }\n                }\n                // Transition\n                if (0 < this._transitions.length) {\n                    const transition = this._transitions.find((item) => trigger.trigger == item.trigger)\n                    if (transition) {\n                        this._transitFrom = transition.from\n                        this._transitTo = transition.to\n                        return true\n                    }\n                }\n            }\n            // Completion Transition (selectable)\n            this._argsOfTrigger = undefined\n            for (const transition of this._completionTransitionSelectables) {\n                if (this._doCallbackSelectable(transition)) {\n                    return true\n                }\n            }\n            // Completion Transition\n            this._argsOfTrigger = undefined\n            if (this._completionTransition) {\n                const transition = this._completionTransition\n                this._transitFrom = transition.from\n                this._transitTo = transition.to\n                return true\n            }\n            return false\n        }\n\n        _proc(): ProcNextBehavior {\n            let ret = ProcNextBehavior.Loop // (default) loop\n            switch (this._procNext) {\n                case ProcStatus.Idle:\n                    ret = ProcNextBehavior.Break    // break\n                    break;\n                case ProcStatus.Start:\n                    this._procStart()\n                    this._procNext = ProcStatus.Into\n                    ret = ProcNextBehavior.Event    // event, for start() function.\n                    break;\n                case ProcStatus.Into:\n                    this._procInto()\n                    if (0 > this._state) {\n                        // (INITIAL or FINAL)\n                        this._procNext = ProcStatus.Idle\n                    } else {\n                        this._procNext = ProcStatus.Enter\n                    }\n                    break;\n                case ProcStatus.Enter:\n                    this._procEnter()\n                    this._procNext = ProcStatus.Do\n                    break;\n                case ProcStatus.Do:\n                    this._procDo()\n                    this._procNext = ProcStatus.Transit\n                    ret = ProcNextBehavior.Event    // event\n                    break;\n                case ProcStatus.Transit:\n                    if (this._procTransit()) {\n                        this._procNext = ProcStatus.Exit\n                    } else {\n                        this._procNext = ProcStatus.Do\n                    }\n                    break;\n                case ProcStatus.Exit:\n                    this._procExit()\n                    this._procNext = ProcStatus.Into\n                    break;\n                default:\n                    // panic\n                    this._procNext = ProcStatus.Panic\n                    ret = ProcNextBehavior.Break    // break\n                    break;\n            }\n            return ret\n        }\n\n        _update() {\n            let next: ProcNextBehavior\n            do {\n                next = this._proc()\n            } while (ProcNextBehavior.Loop == next)\n            this._enabledUpdateEvent = (ProcNextBehavior.Event == next)\n        }\n\n        _raiseUpdateEvent(force: boolean = false) {\n            if (force || this._enabledUpdateEvent) {\n                control.raiseEvent(this._updateEventId, this._machineId)\n            }\n        }\n\n        _initialize() {\n            if (!this._initialized) {\n                this._initialized = true\n                const inst: StateMachine = this\n                // update event handler\n                const updateEventId = this._updateEventId\n                const machineId = this._machineId\n                control.onEvent(updateEventId, machineId, function () {\n                    inst._update()\n                })\n                // update event loop\n                const eventLoopInterval = this._eventLoopInterval\n                loops.everyInterval(eventLoopInterval, function () {\n                    inst._raiseUpdateEvent()\n                })\n            }\n        }\n\n        start(state: number): boolean {\n            this._initialize()\n            if (ProcStatus.Idle == this._procNext) {\n                this._defaultState = state\n                this._procNext = ProcStatus.Start\n                this._update()\n                return true\n            } else {\n                return false\n            }\n        }\n\n        fire(trigger: number, args: number[]) {\n            if ((ProcStatus.Idle != this._procNext) && (ProcStatus.Panic != this._procNext)) {\n                // queuing\n                const triggerArgs = new TriggerArgs(trigger, args)\n                this._triggerQueue.push(triggerArgs)\n                // update event\n                this._raiseUpdateEvent(true)\n            }\n        }\n\n        getArgsOfTrigger() {\n            if (this._argsOfTrigger) {\n                return this._argsOfTrigger\n            }\n            return []\n        }\n\n        selectToAt(index: number) {\n            this._selectedToAt = index\n            this._selectedTo = NUMERIC_NAN\n        }\n\n        selectTo(state: number) {\n            this._selectedToAt = NUMERIC_NAN\n            this._selectedTo = state\n        }\n\n        resetTimeout(timeout: number) {\n            if (0 > timeout) {\n                this._timeoutMillis = NUMERIC_NAN\n            } else {\n                this._timeoutMillis = control.millis() + timeout\n            }\n        }\n\n        timeouted() {\n            if (NUMERIC_NAN == this._timeoutMillis) {\n                return false\n            }\n            return control.millis() >= this._timeoutMillis\n        }\n    }\n\n    // ID-Name conv\n    class IdName {\n        _id: number\n        _name: string\n        constructor(id: number, name: string) {\n            this._id = id\n            this._name = name\n        }\n        get id() { return this._id }\n        get name() { return this._name }\n    }\n\n    let idNameList: IdName[] = []\n\n    function getIdOrNew(name: string) {\n        if (CHAR_ASTERISK == name) {\n            return STATE_INITIAL_FINAL\n        }\n        let idName = idNameList.find((item) => name == item.name)\n        if (undefined == idName) {\n            idName = new IdName(idNameList.length, name)\n            idNameList.push(idName)\n        }\n        return idName.id\n    }\n\n    function convIdToName(id: number, uml: boolean = false) {\n        if (STATE_INITIAL_FINAL == id) {\n            return uml ? \"[\" + CHAR_ASTERISK + \"]\" : CHAR_ASTERISK\n        }\n        let idName = idNameList.find((item) => item.id == id)\n        if (uml) {\n            return undefined == idName ? \"UNDEFINED\" : idName.name\n        } else {\n            return undefined == idName ? \"[\" + id + \"]\" : idName.name\n        }\n    }\n\n    // default ID { id: 0, name: \"\" } - const TRIGGER_NONE = 0      // \"\"(completion)\n    getIdOrNew(\"\")\n\n    // state machine\n    let stateMachineList: StateMachine[] = []   // {index:0, id:1}, {index:1, id:2}, ... {index:n, id:(n+1)}\n\n    function createStateMachine(name: string) {\n        const id = stateMachineList.length + 1\n        const machine = new StateMachine(id, name)\n        stateMachineList.push(machine)\n        return id\n    }\n\n    function getStateMachine(id: number) {\n        const idx = id - 1\n        return stateMachineList[idx]\n    }\n\n    function buildUml(target: StateMachine, defaultState: string, cb: (line: string) => void) {\n        let sp: string\n        const machineName = target.machineName\n\n        sp = \"\" // space(0)\n\n        cb(sp + \"@startuml\")\n        // cb(sp + \"\")\n        // cb(sp + \"' PlantUML Web server:\")\n        cb(sp + \"' http://www.plantuml.com/plantuml/\")\n        cb(sp + \"\")\n        // top state - machine name\n        cb(sp + \"state __\" + machineName + \"__ {\")\n\n        sp = \"  \" // space(2)\n\n        cb(sp + \"\")\n        // cb(sp + \"'=======================\")\n        // cb(sp + \"' description (timeout)\")\n        // cb(sp + \"'=======================\")\n        for (const item of target._declareTransitionTImeouts) {\n            if (!item.asArrow) {\n                cb(sp + \"state \" + convIdToName(item.from, true) + \" : [>\" + item.timeout + \"ms]/ to: \" + convIdToName(item.to, true))\n            }\n        }\n\n        cb(sp + \"\")\n        // cb(sp + \"'=============\")\n        // cb(sp + \"' description \")\n        // cb(sp + \"'=============\")\n        for (const item of target._stateDescriptions) {\n            cb(sp + \"state \" + convIdToName(item.state, true) + \" : \" + item.description)\n        }\n\n        cb(sp + \"\")\n        // cb(sp + \"'============\")\n        // cb(sp + \"' transition \")\n        // cb(sp + \"'============\")\n        cb(sp + convIdToName(STATE_INITIAL_FINAL, true) + \" --> \" + convIdToName(getIdOrNew(defaultState), true) + \" : (start)\")\n        for (const item of target._declareTransitions) {\n            let triggerPart = \"\"\n            if (TRIGGER_NONE != item.trigger) {\n                triggerPart = \" : \" + convIdToName(item.trigger, true)\n            }\n            cb(sp + convIdToName(item.from, true) + \" --> \" + convIdToName(item.to, true) + triggerPart)\n        }\n        for (const item of target._declareTransitionSelectables) {\n            const fromName = convIdToName(item.from, true)\n            const triggerName = convIdToName(item.trigger, true)\n            for (let i = 0; i < item.toList.length; i++) {\n                const toName = convIdToName(item.toList[i], true)\n                const guard = item._guardList[i]\n                let guardPart = \"\"\n                if (undefined === guard) {\n                    guardPart = \" [to \" + toName + \"]\"\n                } else if (guard) {\n                    guardPart = \" [\" + guard + \"]\"\n                }\n                if (triggerName || guardPart) {\n                    cb(sp + fromName + \" --> \" + toName + \" : \" + triggerName + guardPart)\n                } else {\n                    cb(sp + fromName + \" --> \" + toName)   \n                }\n            }\n        }\n        for (const item of target._declareTransitionTImeouts) {\n            if (item.asArrow) {\n                cb(sp + convIdToName(item.from, true) + \" --> \" + convIdToName(item.to, true) + \" : [>\" + item.timeout + \"ms]\")\n            }\n        }\n\n        sp = \"\" // space(0)\n\n        cb(sp + \"}\") // top state - machine name\n        cb(sp + \"@enduml\")\n    }\n\n    const defaultStateMachine: StateMachine = getStateMachine(createStateMachine(DEFAULT_STATE_MACHINE_NAME))\n\n    /**\n     * define state\n     * @param state state\n     * @param body code to run\n     */\n    //% block=\"define $STATE to $state\"\n    //% state.defl=\"State1\"\n    //% draggableParameters=\"reporter\"\n    //% weight=220\n    //% group=\"Design\"\n    export function defineStateName(state: string, body: (STATE: string) => void) {\n        body(state)\n    }\n\n    /**\n     * define state with description\n     * @param state state\n     * @param descriptions array of description\n     * @param body code to run\n     */\n    //% block=\"define $STATE to $state description: $descriptions\"\n    //% state.defl=\"State1\"\n    //% draggableParameters=\"reporter\"\n    //% advanced=true\n    //% weight=210\n    //% group=\"Design\"\n    export function defineStateDescription(state: string, descriptions: string[], body: (STATE: string) => void) {\n        const stateId = getIdOrNew(state)\n        for (const s of descriptions) {\n            defaultStateMachine.addStateDescription(stateId, s)\n        }\n        body(state)\n    }\n\n    /**\n     * convert id (number) to name (string)\n     * @param id state id or trigger id\n     * @returns state name (string) or trigger name (string), if undeclared: \"[<id>]\"\n     */\n    //% block=\"name of $id\"\n    //% advanced=true\n    //% weight=200\n    //% group=\"Action\"\n    export function convName(id: number): string {\n        return convIdToName(id)\n    }\n\n    /**\n     * declare ENTRY action.\n     * prev is a previous state (id).\n     * @param state state\n     * @param body code to run\n     */\n    //% block=\"on entry from $prev : $state\"\n    //% state.defl=\"State1\"\n    //% draggableParameters=\"reporter\"\n    //% handlerStatement\n    //% weight=190\n    //% group=\"Action\"\n    export function declareEntry(state: string, body: (prev: number) => void) {\n        defaultStateMachine.declareEntry(\n            getIdOrNew(state),\n            body\n        )\n    }\n\n    /**\n     * declare DO action.\n     * @param state state\n     * @param ms interval time (milliseconds)\n     * @param body code to run\n     */\n    //% block=\"on do every $ms ms : $state\"\n    //% state.defl=\"State1\"\n    //% ms.shadow=\"timePicker\"\n    //% handlerStatement\n    //% weight=180\n    //% group=\"Action\"\n    export function declareDo(state: string, ms: number, body: () => void) {\n        defaultStateMachine.declareDo(\n            getIdOrNew(state),\n            ms,\n            body\n        )\n    }\n\n    /**\n     * declare EXIT action.\n     * next is a next state (id).\n     * @param state state\n     * @param body code to run\n     */\n    //% block=\"on exit to $next : $state\"\n    //% state.defl=\"State1\"\n    //% draggableParameters=\"reporter\"\n    //% handlerStatement\n    //% weight=170\n    //% group=\"Action\"\n    export function declareExit(state: string, body: (next: number) => void) {\n        defaultStateMachine.declareExit(\n            getIdOrNew(state),\n            body\n        )\n    }\n\n    /**\n     * declare transition.\n     * @param from state, transition from\n     * @param to state, transition to\n     * @param trigger trigger\n     */\n    //% block=\"trasition to $to when $trigger : $from\"\n    //% from.defl=\"State1\"\n    //% to.defl=\"State2\"\n    //% trigger.defl=\"Trigger1\"\n    //% weight=160\n    //% group=\"Transition\"\n    export function declareTransition(from: string, to: string, trigger: string) {\n        // trigger: \"*\" --> \"\"(completion)\n        if (CHAR_ASTERISK == trigger) {\n            trigger = \"\"\n        }\n        defaultStateMachine.declareTransition(\n            getIdOrNew(from),       // \"*\": INITIAL\n            getIdOrNew(to),         // \"*\": FINAL\n            getIdOrNew(trigger)     // trigger: \"*\" --> \"\"(completion)\n        )\n    }\n\n    /**\n     * declare selectable transition.\n     * @param from state, transition from\n     * @param toOptions options of state, transition to\n     * @param trigger trigger\n     * @param body code to run\n     */\n    //% block=\"trasition to $toOptions when $trigger : $from\"\n    //% from.defl=\"State1\"\n    //% trigger.defl=\"Trigger1\"\n    //% handlerStatement\n    //% advanced=true\n    //% weight=150\n    //% group=\"Transition\"\n    export function declareTransitionSelectable(from: string, toOptions: string[], trigger: string, body: () => void) {\n        // trigger: \"*\" --> \"\"(completion)\n        if (CHAR_ASTERISK == trigger) {\n            trigger = \"\"\n        }\n        let toList: number[] = []\n        let guardList: string[] = []\n        for (const s of toOptions) {\n            // [<guard>?]<state name>\n            const idx = s.indexOf(CHAR_GUARD)\n            if (0 > idx) {\n                // state only\n                toList.push(getIdOrNew(s))      // \"*\": FINAL\n                guardList.push(undefined)\n            } else {\n                // guard and state\n                const guard = s.slice(0, idx)\n                const name = s.slice(idx+1)\n                toList.push(getIdOrNew(name))   // \"*\": FINAL\n                guardList.push(guard)\n            }\n        }\n        defaultStateMachine.declareTransitionSelectable(\n            getIdOrNew(from),       // \"*\": INITIAL\n            toList,                 // \"*\": FINAL\n            getIdOrNew(trigger),    // trigger: \"*\" --> \"\"(completion)\n            body,\n            guardList\n        )\n    }\n\n    /**\n     * declare timeout transition.\n     * @param from (States) state, transition from\n     * @param to (States) state, transition to\n     * @param timeout timeout (ms)\n     * @param asArrow display as arrows in diagrams, UML\n     */\n    //% block=\"trasition to $to when timeout $timeout ms : $from (Arrow:$asArrow)\"\n    //% from.defl=\"State1\"\n    //% to.defl=\"State2\"\n    //% timeout.shadow=\"timePicker\"\n    //% timeout.defl=500\n    //% asArrow.shadow=\"toggleOnOff\"\n    //% asArrow.defl=true\n    //% inlineInputMode=inline\n    //% weight=140\n    //% group=\"Transition\"\n    export function declareTransitionTimeout(from: string, to: string, timeout: number, asArrow: boolean) {\n        defaultStateMachine.declareTransitionTimeout(\n            getIdOrNew(from),       // \"*\": INITIAL\n            getIdOrNew(to),         // \"*\": FINAL\n            timeout,\n            asArrow\n        )\n    }\n\n    /**\n     * reset timeout\n     * @param timeout timeout (ms)\n     */\n    //% block=\"timeout: $timeout (ms)\"\n    //% timeout.shadow=\"timePicker\"\n    //% timeout.defl=500\n    //% advanced=true\n    //% weight=130\n    //% group=\"Transition\"\n    export function resetTimeout(timeout: number) {\n        defaultStateMachine.resetTimeout(timeout)\n    }\n\n    /**\n     * timeouted\n     */\n    //% block=\"timeouted\"\n    //% advanced=true\n    //% weight=125\n    //% group=\"Transition\"\n    export function timeouted() {\n        return defaultStateMachine.timeouted()\n    }\n\n    /**\n     * get args of trigger\n     */\n    //% block=\"args of tringger\"\n    //% advanced=true\n    //% weight=120\n    //% group=\"Transition\"\n    export function getArgsOfTrigger() {\n        return defaultStateMachine.getArgsOfTrigger()\n    }\n\n    /**\n     * Select state transition to in declareTransitionSelectable body\n     * @param index states index\n     */\n    //% block=\"select to: at $index\"\n    //% index.defl=0\n    //% advanced=true\n    //% weight=110\n    //% group=\"Transition\"\n    export function selectToAt(index: number) {\n        defaultStateMachine.selectToAt(index)\n    }\n\n    /**\n     * Select state transition to in declareTransitionSelectable body\n     * @param state state to\n     */\n    //% block=\"select to: $state\"\n    //% state.defl=\"State1\"\n    //% advanced=true\n    //% weight=110\n    //% group=\"Transition\"\n    //% deprecated=true\n    export function selectTo(state: string) {\n        defaultStateMachine.selectTo(getIdOrNew(state))\n    }\n\n    /**\n     * fire trigger\n     * @param trigger trigger\n     */\n    //% block=\"fire $trigger\"\n    //% trigger.defl=\"Trigger1\"\n    //% weight=105\n    //% group=\"Command\"\n    export function fire(trigger: string) {\n        defaultStateMachine.fire(getIdOrNew(trigger), undefined)\n    }\n\n    /**\n     * fire trigger\n     * @param trigger trigger\n     * @param args args\n     */\n    //% block=\"fire $trigger args: $args\"\n    //% trigger.defl=\"Trigger1\"\n    //% advanced=true\n    //% weight=100\n    //% group=\"Command\"\n    export function fireWithArgs(trigger: string, args: number[]) {\n        defaultStateMachine.fire(getIdOrNew(trigger), args)\n    }\n\n    /**\n     * start state machine\n     * @param state default state\n     */\n    //% block=\"start $state\"\n    //% state.defl=\"State1\"\n    //% weight=90\n    //% group=\"Command\"\n    export function start(state: string) {\n        defaultStateMachine.start(getIdOrNew(state))\n    }\n\n    /**\n     * export UML, PlantUML\n     * PlantUML Web server: http://www.plantuml.com/plantuml/\n     * @param state default state\n     * @param enabled\n     * @param body code to run\n     */\n    //% block=\"UML $enabled $line : $state\"\n    //% state.defl=\"State1\"\n    //% enabled.shadow=\"toggleOnOff\"\n    //% enabled.defl=true\n    //% draggableParameters=\"reporter\"\n    //% handlerStatement\n    //% advanced=true\n    //% weight=80\n    //% group=\"Command\"\n    export function exportUml(state: string, enabled: boolean, body: (line: string) => void) {\n        if (enabled) {\n            buildUml(defaultStateMachine, state, body)\n        }\n        // if (enabled) {\n        //     body(\"@startuml\")\n        //     body(\"' server: http://www.plantuml.com/plantuml/\")\n        //     body(\"state default {\")\n        //     body(\"  \")\n        //     body(\"  '=============\")\n        //     body(\"  ' description \")\n        //     body(\"  '=============\")\n        //     body(\"  state State : description\")\n        //     body(\"  \")\n        //     body(\"  '============\")\n        //     body(\"  ' transition \")\n        //     body(\"  '============\")\n        //     body(\"  [*] --> State: (start)\")\n        //     body(\"  State --> A: Trigger1[to A]\")\n        //     body(\"  State --> B: Trigger1[to B]\")\n        //     body(\"  State --> C: Trigger1[to C]\")\n        //     body(\"  A --> B: Trigger2\")\n        //     body(\"  A --> C: Trigger3\")\n        //     body(\"  B --> C\")\n        //     body(\"  C --> [*] \")\n        //     body(\"  \")\n        //     body(\"}\")\n        //     body(\"@enduml\")\n        // }\n    }\n}\n","pxt.json":"{\n    \"name\": \"pxt-mstate\",\n    \"version\": \"0.3.2\",\n    \"description\": \"Let's try state machine with micro:bit!\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"mstate.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.17\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\n\nfunction blinkLED () {\n    if (0 == blinkNext) {\n        blinkNext = 1\n        led.setBrightness(100)\n    } else {\n        blinkNext = 0\n        led.setBrightness(255)\n    }\n}\nmstate.defineStateDescription(\"Off\", [\"entry/\", \"- LED off\"], function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        basic.clearScreen()\n    })\n    mstate.declareExit(STATE, function (next) {\n        mode = 0\n    })\n    mstate.declareTransition(STATE, \"On\", \"A\")\n})\nmstate.defineStateDescription(\"On\", [\"entry/\\\\n - Initialize On/Blink\\\\n - LED Heart\"], function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        led.setBrightness(255)\n        blinkNext = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareTransition(STATE, \"Slow\", \"A\")\n    mstate.declareTransition(STATE, \"Slow\", \"Auto\")\n    mstate.declareTransition(STATE, \"Off\", \"B\")\n})\nmstate.defineStateDescription(\"Slow\", [\"entry/\\\\n - reset blinkCount\", \"do/ (500ms)\\\\n - LED blink\\\\n [Auto Mode] 6times\"], function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        blinkCount = 0\n    })\n    mstate.declareDo(STATE, 500, function () {\n        blinkCount += 1\n        if (1 == mode && 6 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareTransition(STATE, \"Fast\", \"A\")\n    mstate.declareTransitionSelectable(STATE, [\"Fast\"], \"\", function () {\n        if (0 > blinkCount) {\n            mstate.selectTo(\"Fast\")\n        }\n    })\n    mstate.declareTransition(STATE, \"Off\", \"B\")\n})\nmstate.defineStateDescription(\"Fast\", [\"entry/\\\\n - reset blinkCount\", \"do/ (200ms)\\\\n - LED blink\\\\n [Auto Mode] 16times\"], function (STATE) {\n    mstate.declareEntry(STATE, function (prev) {\n        blinkCount = 0\n    })\n    mstate.declareDo(STATE, 200, function () {\n        blinkCount += 1\n        if (1 == mode && 15 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareTransition(STATE, \"On\", \"A\")\n    mstate.declareTransitionSelectable(STATE, [\"Slow\"], \"\", function () {\n        if (0 > blinkCount) {\n            mstate.selectTo(\"Slow\")\n        }\n    })\n    mstate.declareTransition(STATE, \"Off\", \"B\")\n})\ninput.onButtonPressed(Button.A, function () {\n    mstate.fire(\"A\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(\"B\")\n})\ninput.onButtonPressed(Button.AB, function () {\n    mstate.fire(\"Auto\")\n    mode = 1\n})\nlet mode = 0\nlet blinkCount = 0\nlet blinkNext = 0\nmstate.exportUml(\"Off\", true, function (line) {\n    console.log(line)\n})\nmstate.start(\"Off\")\n"}