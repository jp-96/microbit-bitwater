{"README.md":"\n> Open this page at GitHub Pages: [https://jp-rad.github.io/pxt-mstate/](https://jp-rad.github.io/pxt-mstate/)\n\n## Preface\n\nThe pxt-mstate extension is a user-defined extension for micro:bit that enables state machine-based coding.\n\nA state machine is a model that represents transitions from one state to another and can represent complex behavior in a simple way.\nUsually, state machines are drawn as state diagrams using tools such as UML, from which source code is generated.\nHowever, the pxt-mstate extension provides the ability to automatically generate state diagrams from coding.\n\nThe pxt-mstate extension allows you to directly define states and transitions using block coding, and to traverse states in response to triggers.\nYou can also visualize them in a state diagram to understand the behavior of your state machine.\n\nGet the pxt-mstate extension into your projects and enjoy programming with state machines! ðŸ˜Š.\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-rad/pxt-mstate** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-rad/pxt-mstate/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-rad/pxt-mstate** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/statics/blocks.png)\n\n\n**Example**\n\n```javascript\nfunction blinkLED (enabled: boolean) {\n    if (!(enabled)) {\n        blink = 1\n    }\n    led.setBrightness(blink * 155 + 100)\n    blink += 1\n    blink = blink % 2\n}\ninput.onButtonPressed(Button.A, function () {\n    mstate.start(StateMachines.M0, \"State1\")\n})\nmstate.defineState(StateMachines.M0, \"State1\", function () {\n    mstate.descriptionUml(\"Blink Heart Icon\")\n    mstate.declareEntry(function () {\n        blinkLED(false)\n        basic.showIcon(IconNames.Heart, 20)\n    })\n    mstate.declareDoActivity(500, function (counter) {\n        if (0 < counter) {\n            blinkLED(true)\n        }\n    })\n    mstate.declareExit(function () {\n        blinkLED(false)\n        basic.showIcon(IconNames.Happy)\n    })\n    mstate.declareSimpleTransition(\"Trigger1\", \"\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.sendTrigger(StateMachines.M0, \"Trigger1\")\n})\nlet blink = 0\nmstate.exportUml(StateMachines.M0, \"State1\")\nbasic.showString(\"M\")\n\n```\n\n**UML**\n\n![A rendered view of UML](https://github.com/jp-rad/pxt-mstate/raw/master/.github/statics/uml.png)\n\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n    /**\n     * micro:bit Message Bus ID of listener : 1-65535\n     * Custom Message Bus ID : 32768-65535\n     * https://github.com/jp-rad/pxt-ubit-extension/blob/master/doc/CustomMicroBit.h\n     */\n\n    declare const enum MSTATE_BUS_ID\n    {\n    /**\n     * MState Update Event Bus ID.\n     * (32768 + 1024 + 5 = 33797)\n     */\n    MSTATE_ID_UPDATE = 33797,\n    // https://github.com/jp-rad/pxt-mstate/\n    }\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"pxt-mstate\",\n    \"version\": \"0.9.1\",\n    \"description\": \"The pxt-mstate extension is a user-defined extension for micro:bit that simplifies state machine coding and visualization using block coding and state diagrams.\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"src/mmachine.ts\",\n        \"src/mstate.ts\",\n        \"src/mstatedevice.h\",\n        \"src/mstateuml.cpp\",\n        \"src/mstateuml.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.25\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","src/mmachine.ts":"// MIT License\n// \n// Copyright (c) 2023-2024 jp-rad\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nnamespace mmachine {\n    export type GetElapsedMillisCallback = () => number\n\n    /**\n     * *device-dependent:* getElapsedMillis;\n     * gets the number of milliseconds elapsed since power on.\n     */\n    export let getElapsedMillis: GetElapsedMillisCallback // = () => 0\n\n    export type QueueRunToCompletionCallback = (machineId: number) => void\n\n    /**\n     * *device-dependent:* queueRunToCompletion;\n     * post run-to-completion event queue for calling back runToCompletion()\n     */\n    export let queueRunToCompletion: QueueRunToCompletionCallback // = (machineId: number) => { }\n\n    export namespace namestore {\n        export const SYS_START_TRIGGER_ID = -1  // StarterTransition\n        export const NONE_ID = 0    //  0 - INITIAL/FINAL/Completion Transition\n        export const NONE_STR = \"\"  // \"\" - INITIAL/FINAL/Completion Transition\n        export let storeNameId: any = {}\n        storeNameId[NONE_STR] = NONE_ID\n        export function getNameIdOrNew(name: string): number {\n            let id = storeNameId[name]\n            if (undefined === id) {\n                id = Object.keys(storeNameId).length\n                storeNameId[name] = id\n            }\n            return id\n        }\n    }\n\n    export type DoActivityCallback = (counter: number) => void\n\n    export class DoActivity {\n        interval_ms: number\n        counterIfPositive: number   // (<0): reseted, 0: reserved, (>0): to executie\n        execute: DoActivityCallback\n        constructor(ms: number, cb: DoActivityCallback) {\n            this.interval_ms = ms\n            this.counterIfPositive = -1  // reset\n            this.execute = cb\n        }\n        executeIf(): boolean {\n            const counter = this.counterIfPositive\n            this.counterIfPositive = -1  // reset\n            if (0 < counter) {\n                this.execute(counter)\n                return true\n            }\n            return false\n        }\n    }\n\n    export class StateTransition {\n        triggerId: number\n        targetIdList: number[]\n        execute: Action\n        constructor(triggerId: number, targetIdList: number[], cb: Action) {\n            this.triggerId = triggerId\n            this.targetIdList = targetIdList\n            this.execute = cb\n        }\n    }\n\n    export class State {\n        stateId: number\n        entryActionList: Action[]\n        doActivityList: DoActivity[]\n        exitActionList: Action[]\n        stateTransitionList: StateTransition[]\n        constructor(stateId: number) {\n            this.stateId = stateId\n            this.entryActionList = []\n            this.doActivityList = []\n            this.exitActionList = []\n            this.stateTransitionList = []\n        }\n    }\n\n    class TriggerIdArgs {\n        triggerId: number\n        triggerArgs: number[]\n        constructor(triggerId: number, triggerArgs?: number[]) {\n            this.triggerId = triggerId\n            this.triggerArgs = triggerArgs || []\n        }\n    }\n\n    enum RunToCompletionStep {\n        WaitPoint,\n        EvalTrigger,\n        EvalCompletion,\n        Reached,\n    }\n\n    export class StateMachine {\n        static readonly TRAVERSE_AT_UNSELECTED = -1 // (default) unselected\n\n        machineId: number\n        _stateList: State[]\n        _triggerEventPool: TriggerIdArgs[]\n        triggerArgs: number[]\n        traverseAt: number   // >=0: selected, <0: unselected\n        _traversingTargetId: number\n        _currentState: State\n        _isDelayed: boolean\n\n        constructor(machineId: number) {\n            this._stateList = []\n            this._triggerEventPool = []\n            this.triggerArgs = []\n            this.traverseAt = StateMachine.TRAVERSE_AT_UNSELECTED\n            this._traversingTargetId = namestore.NONE_ID\n            this._isDelayed = false\n\n            this.machineId = machineId\n\n            const finalState = this.getStateOrNew(namestore.NONE_ID)\n            this._currentState = finalState\n        }\n\n        getStateOrNew(stateId: number) {\n            const obj = this._stateList.find(item => stateId == item.stateId)\n            if (obj) {\n                return obj\n            }\n            const newObj = new State(stateId)\n            this._stateList.push(newObj)\n            return newObj\n        }\n\n        _procEvalDoCounter() {\n            let executed = false\n            for (const doActivity of this._currentState.doActivityList) {\n                if (doActivity.executeIf()) {\n                    executed = true\n                }\n            }\n            return executed\n        }\n\n        _evaluateStateTransition(props: TriggerIdArgs) {\n            // StarterTransition\n            if (namestore.NONE_ID == this._currentState.stateId) {\n                if (namestore.SYS_START_TRIGGER_ID == props.triggerId) {\n                    this._traversingTargetId = props.triggerArgs[0] || namestore.NONE_ID    // default state id, `start` function\n                    return true\n                }\n                return false\n            }\n            // StateTransition\n            const stateTransitionList = this._currentState.stateTransitionList.filter(item => props.triggerId == item.triggerId)\n            for (const stateTransition of stateTransitionList) {\n                this.traverseAt = StateMachine.TRAVERSE_AT_UNSELECTED   // reset\n                this.triggerArgs = props.triggerArgs                    // current trigger args\n                stateTransition.execute()                               // callback body(), evaluating\n                if (0 <= this.traverseAt && stateTransition.targetIdList.length > this.traverseAt) {\n                    this._traversingTargetId = stateTransition.targetIdList[this.traverseAt]\n                    return true\n                }\n            }\n            return false\n        }\n\n        _procEvalTrigger() {\n            while (0 < this._triggerEventPool.length) {\n                const trigger = this._triggerEventPool.shift()  // trigger from event pool\n                if (this._evaluateStateTransition(trigger)) {\n                    return true\n                }\n            }\n            return false\n        }\n\n        runToCompletion() {\n            let nextStep: RunToCompletionStep\n            if (this._isDelayed) {\n                this._isDelayed = false\n                nextStep = RunToCompletionStep.EvalCompletion\n            } else {\n                nextStep = RunToCompletionStep.EvalTrigger\n            }\n            while (RunToCompletionStep.WaitPoint != nextStep) {\n                switch (nextStep) {\n                    case RunToCompletionStep.EvalTrigger:\n                        if (this._procEvalTrigger()) {\n                            nextStep = RunToCompletionStep.Reached\n                        } else if (this._procEvalDoCounter()) {\n                            nextStep = RunToCompletionStep.EvalCompletion\n                        } else {\n                            nextStep = RunToCompletionStep.WaitPoint\n                        }\n                        break;\n                    case RunToCompletionStep.EvalCompletion:\n                        const trigger = new TriggerIdArgs(namestore.NONE_ID) // trigger for Completion Transition\n                        if (this._evaluateStateTransition(trigger)) {\n                            nextStep = RunToCompletionStep.Reached\n                        } else {\n                            nextStep = RunToCompletionStep.EvalTrigger\n                        }\n                        break;\n                    case RunToCompletionStep.Reached:\n                        // exit\n                        for (const cb of this._currentState.exitActionList) {\n                            cb()\n                        }\n                        // changing\n                        this._currentState = this.getStateOrNew(this._traversingTargetId)\n                        const intervalList: number[] = []\n                        for (const v of this._currentState.doActivityList) {\n                            v.counterIfPositive = -1  // clear\n                            intervalList.push(v.interval_ms)\n                        }\n                        resetDoCounterSchedules(this.machineId, intervalList)\n                        // entry\n                        for (const cb of this._currentState.entryActionList) {\n                            cb()\n                        }\n                        // doActivity zero\n                        for (const doActivity of this._currentState.doActivityList) {\n                            doActivity.execute(0)   // counter = 0\n                        }\n                        nextStep = RunToCompletionStep.WaitPoint\n                        this._isDelayed = true\n                        queueRunToCompletion(this.machineId)\n                        break;\n                    default:    // WaitPoint\n                        break;\n                }\n            }\n        }\n\n        send(triggerId: number, triggerArgs: number[]) {\n            this._triggerEventPool.push(new TriggerIdArgs(triggerId, triggerArgs))\n            queueRunToCompletion(this.machineId)\n        }\n    }\n\n    let _defineMachineState: [boolean, StateMachines, number] = [false, undefined, undefined]\n\n    export function defineState(machineId: number, stateId: number, body: () => void) {\n        _defineMachineState = [true, machineId, stateId]\n        body()\n        _defineMachineState = [false, undefined, undefined]\n    }\n\n    export function getDefineMachineState() {\n        return _defineMachineState\n    }\n\n    const _stateMachineList: mmachine.StateMachine[] = []\n\n    export function getStateMachine(machineId: number) {\n        const obj = _stateMachineList.find(item => machineId == item.machineId)\n        if (obj) {\n            return obj\n        }\n        const newObj = new mmachine.StateMachine(machineId)\n        _stateMachineList.push(newObj)\n        return newObj\n    }\n\n    export function getState(machineId: number, stateId: number): mmachine.State {\n        return getStateMachine(machineId).getStateOrNew(stateId)\n    }\n\n    export function runToCompletion(machineId: number) {\n        getStateMachine(machineId).runToCompletion()\n    }\n\n    class DoCounterSchedule {\n        machineId: number\n        doActivityIndex: number\n        interval: number\n        nextTimestamp: number\n        counter: number\n    }\n\n    let _doCounterScheduleList: DoCounterSchedule[] = []\n\n    function resetDoCounterSchedules(machineId: number, intervalList: number[]) {\n        const currentTimestamp = getElapsedMillis()\n        _doCounterScheduleList = _doCounterScheduleList.filter(item => machineId != item.machineId)\n        intervalList.forEach((value, index) => {\n            if (0 < value) {\n                const schedule = new DoCounterSchedule()\n                _doCounterScheduleList.push(schedule)\n                schedule.machineId = machineId\n                schedule.doActivityIndex = index\n                schedule.interval = value\n                schedule.nextTimestamp = currentTimestamp + schedule.interval\n                schedule.counter = 0\n            }\n        })\n    }\n\n    export function idleTick() {\n        const currentTimestamp = getElapsedMillis()\n        // do-counter scheduler\n        for (const schedule of _doCounterScheduleList) {\n            if (currentTimestamp >= schedule.nextTimestamp) {\n                while (currentTimestamp >= schedule.nextTimestamp) {\n                    schedule.nextTimestamp = schedule.nextTimestamp + schedule.interval\n                    schedule.counter = schedule.counter + 1\n                }\n                const doActivity = getStateMachine(schedule.machineId)._currentState.doActivityList[schedule.doActivityIndex]\n                if (doActivity) {\n                    doActivity.counterIfPositive = schedule.counter\n                    queueRunToCompletion(schedule.machineId)\n                }\n            }\n        }\n    }\n}\n","src/mstate.ts":"/// <reference path=\"mmachine.ts\" />\n/// <reference path=\"mstateuml.ts\" />\n\nenum StateMachines {\n    M0 = 0,\n    M1,\n    M2,\n    M3,\n    M4,\n    M5\n}\n\n/**\n * mstate blocks: The pxt-mstate extension is a user-defined extension for micro:bit that simplifies state machine coding and visualization using block coding and state diagrams.\n */\n//% weight=100 color=\"#40A070\" icon=\"\\uf362\"\n//% groups=\"['Command', 'Declare', 'Transition', 'UML]\"\nnamespace mstate {\n\n    /**\n     * *device-dependent:* initialize and activate\n     */\n    namespace deviceSetup {\n\n        mstate._doc = console.log\n\n        mmachine.getElapsedMillis = () =>\n            // milliseconds\n            control.millis()\n\n        mmachine.queueRunToCompletion = (machineId: number) =>\n            // raise event : post run-to-completion event queue for calling back runToCompletion()\n            control.raiseEvent(MSTATE_BUS_ID.MSTATE_ID_UPDATE, machineId)\n\n        control.onEvent(MSTATE_BUS_ID.MSTATE_ID_UPDATE, 0, function () {\n            // on event : post run-to-completion event queue for calling back runToCompletion()\n            const machineId = control.eventValue()\n            mmachine.runToCompletion(machineId)\n        })\n\n        basic.forever(function () {\n            //  do-counter : calling idleTick()\n            // loop - 20ms\n            mmachine.idleTick()\n        })\n\n    }\n\n    /**\n     * define state\n     * @param aStateMachine StateMachines\n     * @param aStateName state name\n     * @param body code to run\n     */\n    //% block=\"define $aStateMachine state $aStateName\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% aStateName.defl=\"a\"\n    //% weight=180\n    //% group=\"Declare\"\n    export function defineState(aStateMachine: StateMachines, aStateName: string, body: () => void) {\n        mmachine.defineState(aStateMachine, mmachine.namestore.getNameIdOrNew(aStateName), function () {\n            const [enabled, machineId, stateId] = mmachine.getDefineMachineState()\n            if (enabled) {\n                body()\n                // uml\n                mstate._simuStateUml(machineId, stateId)\n            }\n        })\n    }\n\n    /**\n     * declare entry action.\n     * @param body code to run\n     */\n    //% block=\"mstate on entry\"\n    //% handlerStatement\n    //% weight=170\n    //% group=\"Declare\"\n    export function declareEntry(body: () => void) {\n        const [enabled, machineId, stateId] = mmachine.getDefineMachineState()\n        if (enabled) {\n            mmachine.getState(machineId, stateId).entryActionList.push(body)\n            // uml\n            mstate._simuStateUml(machineId, stateId)\n        }\n    }\n\n    /**\n     * declare doActivity.\n     * @param aEvery interval time (milliseconds)\n     * @param body code to run\n     */\n    //% block=\"mstate on do every $aEvery ms $counter\"\n    //% aEvery.shadow=\"timePicker\"\n    //% aEvery.defl=1000\n    //% handlerStatement\n    //% draggableParameters\n    //% weight=160\n    //% group=\"Declare\"\n    export function declareDoActivity(aEvery: number, body: (counter: number) => void) {\n        const [enabled, machineId, stateId] = mmachine.getDefineMachineState()\n        if (enabled) {\n            if (mmachine.namestore.NONE_ID != stateId) {\n                mmachine.getState(machineId, stateId).doActivityList.push(new mmachine.DoActivity(aEvery, body))\n                // uml\n                mstate._simuStateUml(machineId, stateId)\n            }\n        }\n    }\n\n    /**\n     * declare exit action.\n     * @param body code to run\n     */\n    //% block=\"mstate on exit\"\n    //% handlerStatement\n    //% weight=150\n    //% group=\"Declare\"\n    export function declareExit(body: () => void) {\n        const [enabled, machineId, stateId] = mmachine.getDefineMachineState()\n        if (enabled) {\n            mmachine.getState(machineId, stateId).exitActionList.push(body)\n            // uml\n            mstate._simuStateUml(machineId, stateId)\n        }\n    }\n\n    /**\n     * declare simple transition.\n     * @param aTriggerName trigger name\n     * @param aTargetName target state name\n     */\n    //% block=\"mstate transition trigger $aTriggerName target $aTargetName\"\n    //% aTriggerName.defl=\"e\"\n    //% aTargetName.defl=\"a\"\n    //% weight=140\n    //% group=\"Transition\"\n    export function declareSimpleTransition(aTriggerName: string, aTargetName: string) {\n        const [enabled, machineId, _] = mmachine.getDefineMachineState()\n        if (enabled) {\n            declareStateTransition(aTriggerName, [aTargetName], function () {\n                mstate.traverse(machineId, 0)\n            })\n        }\n    }\n\n    /**\n     * declare state transition.\n     * @param aTriggerName trigger name\n     * @param aTargetNameList array of target state name \n     * @param body code to run\n     */\n    //% block=\"mstate transition trigger $aTriggerName targets $aTargetNameList\"\n    //% aTriggerName.defl=\"e\"\n    //% draggableParameters=\"reporter\"\n    //% handlerStatement\n    //% weight=130\n    //% group=\"Transition\"\n    export function declareStateTransition(aTriggerName: string, aTargetNameList: string[], body: () => void) {\n        const [enabled, machineId, stateId] = mmachine.getDefineMachineState()\n        if ((enabled) && (mmachine.namestore.NONE_ID != stateId)) {\n            const triggerId = mmachine.namestore.getNameIdOrNew(aTriggerName)\n            const targetIdList: number[] = []\n            for (const s of aTargetNameList) {\n                targetIdList.push(mmachine.namestore.getNameIdOrNew(s))\n            }\n            mmachine.getState(machineId, stateId).stateTransitionList.push(new mmachine.StateTransition(triggerId, targetIdList, body))\n            // uml\n            mstate._simuTransitionUml(machineId, stateId)\n        }\n    }\n\n    /**\n     * get trigger args.\n     * @param aStateMachine StateMachines\n     */\n    //% block=\"mstate $aStateMachine trigger args\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% weight=120\n    //% group=\"Transition\"\n    //% advanced=true\n    export function getTriggerArgs(aStateMachine: StateMachines,): number[] {\n        return mmachine.getStateMachine(aStateMachine).triggerArgs\n    }\n\n    /**\n     * traverse, select target index\n     * @param aStateMachine StateMachines\n     * @param index target index, cancled = (-1)\n     */\n    //% block=\"mstate $aStateMachine traverse at $index\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% index.defl=0\n    //% weight=110\n    //% group=\"Transition\"\n    export function traverse(aStateMachine: StateMachines, index: number) {\n        mmachine.getStateMachine(aStateMachine).traverseAt = index\n    }\n\n    /**\n     * send trigger\n     * @param aStateMachine StateMachines\n     * @param aTriggerName trigger name\n     */\n    //% block=\"send $aStateMachine $aTriggerName\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% aTriggerName.defl=\"e\"\n    //% weight=100\n    //% group=\"Command\"\n    export function sendTrigger(aStateMachine: StateMachines, aTriggerName: string) {\n        sendTriggerArgs(aStateMachine, aTriggerName, [])\n    }\n\n    /**\n     * send trigger with args\n     * @param aStateMachine StateMachines\n     * @param aTriggerName trigger name\n     * @param aTriggerArgs trigger args\n     */\n    //% block=\"send $aStateMachine $aTriggerName $aTriggerArgs\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% aTriggerName.defl=\"e\"\n    //% weight=90\n    //% group=\"Command\"\n    //% advanced=true\n    export function sendTriggerArgs(aStateMachine: StateMachines, aTriggerName: string, aTriggerArgs: number[]) {\n        const triggerId = mmachine.namestore.getNameIdOrNew(aTriggerName)\n        mmachine.getStateMachine(aStateMachine).send(triggerId, aTriggerArgs)\n    }\n\n    /**\n     * start state machine\n     * @param aStateMachine StateMachines\n     * @param aStateName default state name\n     */\n    //% block=\"start $aStateMachine $aStateName\"\n    //% aStateMachine.defl=StateMachines.M0\n    //% aStateName.defl=\"a\"\n    //% weight=80\n    //% group=\"Command\"\n    export function start(aStateMachine: StateMachines, aStateName: string) {\n        const stateId = mmachine.namestore.getNameIdOrNew(aStateName)\n        mmachine.getStateMachine(aStateMachine).send(mmachine.namestore.SYS_START_TRIGGER_ID, [stateId])    // StarterTransition\n    }\n\n    /**\n     * UML, export\n     * @param aStateMachine StateMachines\n     * @param aStateName default state name\n     * @param aMode output state-diagram, trigger table, JSON-diagram\n     */\n    //% block=\"(UML) $aStateMachine $aStateName||$aMode\"\n    //% inlineInputMode=inline\n    //% aStateMachine.defl=StateMachines.M0\n    //% aStateName.defl=\"a\"\n    //% aMode.defl=ModeExportUML.Both\n    //% weight=70\n    //% group=\"UML\"\n    //% advanced=true\n    //% shim=mstate::dummy_exportUml\n    export function exportUml(aStateMachine: StateMachines, aStateName: string, aMode: ModeExportUML = ModeExportUML.Both) {\n        // uml\n        mstate._simuExportUml(aStateMachine, aStateName, aMode)\n    }\n\n    /**\n     * UML, description\n     * @param aDescription description\n     */\n    //% block=\"(UML) description $aDescription\"\n    //% aDescription.defl=\"a\"\n    //% weight=60\n    //% group=\"UML\"\n    //% advanced=true\n    //% shim=mstate::dummy_descriptionUml\n    export function descriptionUml(aDescription: string) {\n        // uml\n        mstate._simuDescriptionUml(aDescription)\n    }\n\n    /**\n     * UML, descriptions\n     * @param aDescriptionList array of description\n     */\n    //% block=\"(UML) descriptions $aDescriptionList\"\n    //% weight=50\n    //% group=\"UML\"\n    //% advanced=true\n    //% shim=mstate::dummy_descriptionsUml\n    export function descriptionsUml(aDescriptionList: string[]) {\n        // uml\n        mstate._simuDescriptionsUml(aDescriptionList)\n    }\n\n}\n","src/mstatedevice.h":"#ifndef MSTATE_DEVICE_H\r\n#define MSTATE_DEVICE_H\r\n/**\r\n * micro:bit Message Bus ID of listener : 1-65535\r\n * Custom Message Bus ID : 32768-65535\r\n * https://github.com/jp-rad/pxt-ubit-extension/blob/master/doc/CustomMicroBit.h\r\n */\r\nenum MSTATE_BUS_ID\r\n{\r\n        /**\r\n         * MState Update Event Bus ID.\r\n         * (32768 + 1024 + 5 = 33797)\r\n         */\r\n        MSTATE_ID_UPDATE = 33797,\r\n        // https://github.com/jp-rad/pxt-mstate/\r\n};\r\n\r\n#endif // #ifndef MSTATE_DEVICE_H\r\n","src/mstateuml.cpp":"#include \"pxt.h\"\n\nnamespace mstate\n{\n\n    //%\n    void dummy_exportUml(int i, StringData *s, int j)\n    {\n        // only for the simulator\n    }\n\n    //%\n    void dummy_descriptionUml(StringData *a)\n    {\n        // only for the simulator\n    }\n\n    //%\n    void dummy_descriptionsUml(StringData **a)\n    {\n        // only for the simulator\n    }\n\n    //%\n    StringData **dummy_simuLastDescriptionListUML(int i)\n    {\n        // only for the simulator\n    }\n\n    //%\n    void dummy_simuStateUml(int i, int j)\n    {\n        // only for the simulator\n    }\n\n    //%\n    void dummy_simuTransitionUml(int i, int j)\n    {\n        // only for the simulator\n    }\n\n    //%\n    StringData *dummy_simuConvName(int i)\n    {\n        // only for the simulator\n    }\n\n}\n","src/mstateuml.ts":"enum ModeExportUML {\n    //% block=\"Diagram and Table\"\n    Both = 3,\n    //% block=\"State Diagram\"\n    StateDiagram = 1,\n    //% block=\"Trigger Table\"\n    TriggerTable = 2,\n    //% block=\"(JSON)\"\n    JsonDiagram = 0,\n}\n\nnamespace mstate {\n\n    export type OutputDocCallback = (value: any) => void\n\n    /**\n     * *device-dependent:* (internal) UML, export UML\n     */\n    export let _doc: OutputDocCallback = (value: any) => { }\n\n    /**\n     * (internal) UML, description stack\n     * for the simulator\n     */\n    const _lastDescriptionList: string[] = []\n\n    /**\n     * (internal) UML, convert id (number) to state/trigger name (string)\n     * @param nameId state id or trigger id\n     * @returns state name (string) or trigger name (string): \"[id]\" if undefined\n     */\n    //% shim=mstate::dummy_simuConvName\n    export function _simuConvName(nameId: number): string {\n        // for the simulator\n        const storeNameId = mmachine.namestore.storeNameId\n        let name = Object.keys(storeNameId).find((value) => nameId == storeNameId[value])\n        if (undefined === name) {\n            name = \"[\" + nameId + \"]\"\n        }\n        return name\n    }\n\n    /**\n     * (internal) UML, description\n     * @param aDescription description\n     */\n    //% shim=mstate::dummy_descriptionUml\n    export function _simuDescriptionUml(aDescription: string) {\n        // for the simulator\n        _lastDescriptionList.push(aDescription)\n    }\n\n    /**\n     * (internal) UML, descriptions\n     * @param aDescriptionList array of description\n     */\n    //% shim=mstate::dummy_descriptionsUml\n    export function _simuDescriptionsUml(aDescriptionList: string[]) {\n        // for the simulator\n        for (const s of aDescriptionList) {\n            _simuDescriptionUml(s)\n        }\n    }\n\n    /**\n     * (internal) UML, last description list\n     * @param n (-1):all, (0): empty [], (>0): n from last\n     * @returns list of description\n     */\n    //% shim=mstate::dummy_simuLastDescriptionListUML\n    export function _simuLastDescriptionListUML(n: number): string[] {\n        // for the simulator\n        const ret: string[] = []\n        const stack: string[] = []\n        if (0 > n) {\n            n = _lastDescriptionList.length\n        }\n        while ((0 < _lastDescriptionList.length) && (n > stack.length)) {\n            stack.push(_lastDescriptionList.pop())\n        }\n        while (0 < stack.length) {\n            ret.push(stack.pop())\n        }\n        return ret\n    }\n\n    /**\n     * (internal) UML, state\n     * @param machineId  machine id\n     * @param stateId state name\n     */\n    //% shim=mstate::dummy_simuStateUml\n    export function _simuStateUml(machineId: number, stateId: number) {\n        // for the simulator\n        const state: any = mmachine.getState(machineId, stateId)\n        const descList = _simuLastDescriptionListUML(-1)\n        if (0 < descList.length) {\n            state[\"stateDesc\"] = (\n                (state[\"stateDesc\"] ? state[\"stateDesc\"] : []) as string[]\n            ).concat(descList)\n        }\n    }\n\n    /**\n     * (internal) UML, transition\n     * @param machineId machine id\n     * @param stateId state id\n     */\n    //% shim=mstate::dummy_simuTransitionUml\n    export function _simuTransitionUml(machineId: number, stateId: number) {\n        // for the simulator\n        const state = mmachine.getState(machineId, stateId)\n        const stateTransition = state.stateTransitionList[(state.stateTransitionList.length - 1)]\n        const stateTransitionObj: any = stateTransition\n        stateTransitionObj[\"targetDescList\"] = _simuLastDescriptionListUML(stateTransition.targetIdList.length)\n    }\n\n    /**\n     * (internal) UML, export\n     * @param aStateMachine StateMachines\n     * @param aStateName default state name\n     * @param aModeFlag 00b:json, 01b:state-diagram, 10b:trigger table, 11b:(both)\n     */\n    //% shim=mstate::dummy_exportUml\n    export function _simuExportUml(aStateMachine: StateMachines, aStateName: string, aModeFlag: number) {\n        // for the simulator\n        const outputJson = 0 == (aModeFlag & 3)\n        const outputTriggerTable = 0 != (aModeFlag & 2)\n        const outputStateDiagram = 0 != (aModeFlag & 1)\n\n        type MbState = { state: { name: string, desc: string }, isFinalState?: boolean, isChoice?: boolean }\n        type MbTrigger = { trigger: { name: string, desc: string }, isCompletion?: boolean }\n        type MbTransition = { transition: { source: MbState, target: MbState, trigger: MbTrigger, guard: string, effect: string }, isDesc: boolean }\n        type MbStateMachine = { states: MbState[], triggers: MbTrigger[], transitions: MbTransition[] }\n        const compareNameMbState = (a1: MbState, a2: MbState) => {\n            let ret: number = 0\n            if (a1.isFinalState) {\n                ret = 1\n            } else if (a2.isFinalState) {\n                ret = -1\n            } else {\n                const name1 = a1.state.name.toUpperCase()\n                const name2 = a2.state.name.toUpperCase()\n                if (name1 > name2) {\n                    ret = 1\n                } else if (name1 < name2) {\n                    ret = -1\n                }\n            }\n            return ret\n        }\n        const compareNameMbTrigger = (a1: MbTrigger, a2: MbTrigger) => {\n            let ret: number = 0\n            if (a1.isCompletion) {\n                ret = -1\n            } else if (a2.isCompletion) {\n                ret = 1\n            } else {\n                const name1 = a1.trigger.name.toUpperCase()\n                const name2 = a2.trigger.name.toUpperCase()\n                if (name1 > name2) {\n                    ret = 1\n                } else if (name1 < name2) {\n                    ret = -1\n                }\n            }\n            return ret\n        }\n\n        // statemachine json\n        const mb: MbStateMachine = { states: [], triggers: [], transitions: [] }\n\n        // state - initial/final\n        mb.states.push({ state: { name: \"\", desc: \"(initial/final)\" }, isFinalState: true })\n        // trigger - completion transition\n        mb.triggers.push({ trigger: { name: \"\", desc: \"(completion transition)\" }, isCompletion: true })\n        // build states and triggers\n        for (const state of mmachine.getStateMachine(aStateMachine)._stateList) {\n            const stateObj = state as any\n\n            // state\n            const stateName = mstate._simuConvName(state.stateId)\n            let objState = mb.states.find((value) => { return stateName == value.state.name })\n            if (!objState) {\n                const stateDesc = ((stateObj[\"stateDesc\"] ? stateObj[\"stateDesc\"] : []) as string[]).join(\"\\\\n\")\n                objState = { state: { name: stateName, desc: stateDesc } }\n                if ((\"\" == stateDesc)\n                    && (0 == state.entryActionList.length)\n                    && (0 == state.doActivityList.length)\n                    && (0 == state.exitActionList.length)\n                    && (0 < state.stateTransitionList.length)\n                ) {\n                    const t = state.stateTransitionList.find((item) => {\n                        if (mmachine.namestore.NONE_ID != item.triggerId) {\n                            return true\n                        }\n                        const selfTarget = item.targetIdList.find((value) => state.stateId == value)\n                        if (selfTarget) {\n                            return true\n                        }\n                        return false\n                    })\n                    if (!t) {\n                        let targetCount = 0\n                        for (const stateTransition of state.stateTransitionList) {\n                            targetCount += stateTransition.targetIdList.length\n                        }\n                        if (1 < targetCount) {\n                            // <<choice>>\n                            objState.isChoice = true\n                        }\n                    }\n                }\n                mb.states.push(objState)\n            }\n\n            // state transition\n            for (const stateTransition of state.stateTransitionList) {\n                if (mmachine.namestore.SYS_START_TRIGGER_ID == stateTransition.triggerId) {\n                    // for StarterTransition\n                    continue\n                }\n                // trigger\n                const triggerName = mstate._simuConvName(stateTransition.triggerId)\n                let objTrigger = mb.triggers.find((value) => { return triggerName == value.trigger.name })\n                if (!objTrigger) {\n                    objTrigger = { trigger: { name: triggerName, desc: \"\" } }\n                    mb.triggers.push(objTrigger)\n                }\n            }\n        }\n        // build transitions\n        for (const state of mmachine.getStateMachine(aStateMachine)._stateList) {\n\n            // state\n            const stateName = mstate._simuConvName(state.stateId)\n            const source = mb.states.find((value) => { return stateName == value.state.name })\n\n            // stateTransition\n            for (const stateTransition of state.stateTransitionList) {\n                const stateTransitionObj = stateTransition as any\n\n                // trigger\n                const triggerName = mstate._simuConvName(stateTransition.triggerId)\n                const trigger = mb.triggers.find((value) => { return triggerName == value.trigger.name })\n\n                // state transition\n                const targetDescList: string[] = stateTransitionObj[\"targetDescList\"] ? stateTransitionObj[\"targetDescList\"] : []\n                stateTransition.targetIdList.forEach((targetId, index) => {\n                    // transition\n                    const targetName = mstate._simuConvName(targetId)\n                    let target = mb.states.find((value) => { return targetName == value.state.name })\n                    if (!target) {\n                        target = { state: { name: targetName, desc: \"\" } }\n                        mb.states.push(target)\n                    }\n                    let guard = \"\"\n                    let effect = \"\"\n                    let isDesc = false\n                    let s = targetDescList[index]\n                    if (s) {\n                        if (\":\" == s.charAt(0)) {\n                            isDesc = true\n                            s = s.slice(1)\n                        }\n                        const a = s.split(\"/\", 2)\n                        if (a[0]) {\n                            guard = a[0].trim()\n                        }\n                        if (a[1]) {\n                            effect = a[1].trim()\n                        }\n                    }\n                    mb.transitions.push({ transition: { source, target, trigger, guard, effect }, isDesc })\n                })\n            }\n        }\n        // validate <<choise>>\n        for (const stateItem of mb.states) {\n            if (stateItem.isChoice) {\n                const t = mb.transitions.find(item => stateItem == item.transition.target)\n                if (!t) {\n                    // no targets\n                    stateItem.isChoice = false\n                }\n            }\n        }\n        // sort\n        mb.states.sort(compareNameMbState)\n        mb.triggers.sort(compareNameMbTrigger)\n\n        if (outputJson) {\n            // startjson/endjson\n            _doc(\"''''''''''''''''''''''''''\")\n            _doc(\"@startjson\")\n            _doc(\"' \")\n            _doc(\"' PlantUML Web server:\")\n            _doc(\"' https://www.plantuml.com/plantuml/\")\n            _doc(\"' \")\n            _doc(\"' Display JSON Data - https://plantuml.com/json\")\n            _doc(\"' >>>>> JSON\")\n\n            // JSON\n            const stringifyJSON = (value: any, maxStringLength = 240): string[] => {\n                const result: string[] = []\n                const a = JSON.stringify(value, null, 1).split(\"\\n\")\n                a[a.length - 1] = \" \" + a[a.length - 1]\n                let buff: string = \"\"\n                a.forEach((value) => {\n                    if (maxStringLength < buff.length + value.length) {\n                        result.push(buff)\n                        buff = \"\"\n                    }\n                    buff = buff + value\n                })\n                if (0 < buff.length) {\n                    result.push(buff)\n                }\n                return result\n            }\n            stringifyJSON(mb).forEach((s) => _doc(s))\n\n            _doc(\"' <<<<< JSON\")\n            _doc(\"' \")\n            _doc(\"' generator: https://github.com/jp-rad/pxt-mstate\")\n            _doc(\"' \")\n            _doc(\"' PlantUML Web server:\")\n            _doc(\"' https://www.plantuml.com/plantuml/\")\n            _doc(\"' \")\n            _doc(\"@endjson\")\n        }\n\n        if (outputStateDiagram || outputTriggerTable) {\n            // startuml/enduml\n            _doc(\"''''''''''''''''''''''''''\")\n            _doc(\"@startuml\")\n            _doc(\"' \")\n            _doc(\"' PlantUML Web server:\")\n            _doc(\"' https://www.plantuml.com/plantuml/\")\n            _doc(\"' \")\n            _doc(\"' State Diagram - https://plantuml.com/state-diagram\")\n        }\n        if (outputStateDiagram) {\n            // statemachine\n            _doc(\"state __M\" + aStateMachine + \"__ {\")\n\n            // states <<choise>>\n            for (const stateItem of mb.states) {\n                if (stateItem.isChoice) {\n                    _doc(\"state \" + stateItem.state.name + \" <<choice>>\")\n                }\n            }\n\n            // start\n            _doc(\"[*] -> \" + aStateName + \" : <<start>>\")\n\n            // states\n            for (const stateItem of mb.states) {\n                if (stateItem.isFinalState) {\n                    continue\n                }\n                // state\n                const state = stateItem.state\n                if (!stateItem.isChoice) {\n                    _doc(\"state \" + state.name + (state.desc ? \" : \" + state.desc : \"\"))\n                }\n\n                // transitions\n                const transList = mb.transitions.filter(value => (state.name == value.transition.source.state.name))\n                for (const transItem of transList) {\n                    // transition\n                    const transition = transItem.transition\n                    const targetName = transition.target.state.name ? transition.target.state.name : \"[*]\"\n                    let attrPart = ((transition.guard ? \" [ \" + transition.guard + \" ] \" : \"\")\n                        + (transition.effect ? \" / \" + transition.effect : \"\")).trim()\n                    attrPart = (transition.trigger.trigger.name + \" \" + attrPart).trim()\n                    if (attrPart) {\n                        attrPart = \" : \" + attrPart\n                    }\n                    if ((transItem.isDesc) && (!stateItem.isChoice)) {\n                        _doc(\"state \" + transition.source.state.name + \" : --> \" + targetName + attrPart)\n                    } else {\n                        const arrowMarkup = transition.target.state.name ? \" --> \" : \"  -> \"\n                        _doc(transition.source.state.name + arrowMarkup + targetName + attrPart)\n                    }\n                }\n            }\n\n            _doc(\"}\") // statemachine\n\n            _doc(\"' \")\n            _doc(\"' generator: https://github.com/jp-rad/pxt-mstate\")\n            _doc(\"' \")\n            _doc(\"' PlantUML Web server:\")\n            _doc(\"' https://www.plantuml.com/plantuml/\")\n            _doc(\"' \")\n\n        }\n\n        if (outputTriggerTable) {\n            // trigger table\n            _doc(\"json M\" + aStateMachine + \" {\")\n            // build json table rows\n            type TbRow = { key: string, value: any[] }\n            const headerKeyTrigger = \"**trigger**\"\n            const headerKeySource = \"**source**\"\n            const headerValue = [{ \"\": [\"**[guard] / effect**\", \"**target**\"] }]\n            const tbl: TbRow[] = []\n            {\n                function tbAddRow(key: string) {\n                    const sources: any = {}\n                    sources[headerKeySource] = headerValue  // header\n                    for (const state of mb.states) {\n                        if (state.isFinalState) {\n                            continue\n                        }\n                        const sourceName = (state.isChoice ? \"<<choice>>\\\\n\" : \"\") + state.state.name\n                        sources[sourceName] = []\n                    }\n                    tbl.push({ key, value: [sources] })\n                }\n                const completionTriggerName = \"(__completion__)\"\n                for (const triggerItem of mb.triggers) {\n                    // trigger\n                    const triggerName = triggerItem.isCompletion ? completionTriggerName : triggerItem.trigger.name\n                    tbAddRow(triggerName)\n                }\n                // transitions\n                for (const transItem of mb.transitions) {\n                    // transition\n                    const transition = transItem.transition\n                    const triggerName = transition.trigger.isCompletion ? completionTriggerName : transition.trigger.trigger.name\n                    const tbRow = tbl.find(value => triggerName == value.key)\n                    const sourceName = (transition.source.isChoice ? \"<<choice>>\\\\n\" : \"\") + transition.source.state.name\n                    const stateChildren: any[] = tbRow.value[0][sourceName]\n                    const attrPart = ((transition.guard ? \" [ \" + transition.guard + \" ] \" : \"\")\n                        + (transition.effect ? \" / \" + transition.effect : \"\")).trim()\n                    const targetName = (transition.target.isChoice ? \"<<choice>>\\\\n\" : \"\") + transition.target.state.name || \"[__FinalState__]\"\n                    const child = { \"\": [attrPart, targetName] }\n                    stateChildren.push(child)\n                }\n            }\n            // output header\n            _doc('\"' + headerKeyTrigger + '\" : [\"**transitions**\"] ,')\n            // output rows\n            for (const tbRow of tbl) {\n                _doc('\"' + tbRow.key + '\" : ' + JSON.stringify(tbRow.value) + \" ,\")\n            }\n            // output defalut row\n            _doc('\"**__default__**\" : [\"' + aStateName + '\"]')\n            _doc(\"}\") // trigger table\n\n            _doc(\"' \")\n            _doc(\"' generator: https://github.com/jp-rad/pxt-mstate\")\n            _doc(\"' \")\n            _doc(\"' PlantUML Web server:\")\n            _doc(\"' https://www.plantuml.com/plantuml/\")\n            _doc(\"' \")\n\n        }\n        if (outputStateDiagram || outputTriggerTable) {\n            // startuml/enduml\n            _doc(\"@enduml\")\n        }\n    }\n\n}\n","test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\n// blink\nfunction blinkLED () {\n    if (0 == blinkNext) {\n        blinkNext = 1\n        led.setBrightness(100)\n    } else {\n        blinkNext = 0\n        led.setBrightness(255)\n    }\n}\n// State Off\n// entry/\n// - LED off\nmstate.defineState(StateMachines.M0, \"Off\", function () {\n    mstate.descriptionUml(\"LED off\")\n    mstate.declareEntry(function () {\n        basic.clearScreen()\n    })\n    mstate.declareExit(function () {\n        led.setBrightness(255)\n        basic.showString(\"On!\")\n    })\n    mstate.declareSimpleTransition(\"A\", \"On\")\n})\ninput.onButtonPressed(Button.A, function () {\n    mstate.sendTrigger(StateMachines.M0, \"A\")\n})\n// State Fast\n// entry/\n// - reset blinkCount\n// do/ (200ms)\n// - LED blink\n// [Auto Mode] 15times\nmstate.defineState(StateMachines.M0, \"Fast\", function () {\n    mstate.declareEntry(function () {\n        times = 0\n    })\n    mstate.descriptionUml(\"LED blink (200ms)\")\n    mstate.declareDoActivity(200, function (counter) {\n        if (1 == auto && 15 < counter) {\n            times = 15\n        } else if (25 < counter) {\n            times = 25\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.descriptionsUml([\"auto && 15times\", \">5s\"])\n    mstate.declareStateTransition(\"\", [\"Slow\", \"On\"], function () {\n        if (15 == times) {\n            mstate.traverse(StateMachines.M0, 0)\n        } else if (25 == times) {\n            mstate.traverse(StateMachines.M0, 1)\n        }\n    })\n    mstate.declareSimpleTransition(\"A\", \"On\")\n    mstate.descriptionUml(\":\")\n    mstate.declareSimpleTransition(\"B\", \"Off\")\n})\n// Stete On\n// entry/\n// - Initialize On/Blink\n// - LED Heart\nmstate.defineState(StateMachines.M0, \"On\", function () {\n    mstate.descriptionsUml([\"auto=OFF\", \"Heart icon\"])\n    mstate.declareEntry(function () {\n        auto = 0\n        led.setBrightness(255)\n        blinkNext = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareSimpleTransition(\"A\", \"Slow\")\n    mstate.descriptionUml(\":\")\n    mstate.declareSimpleTransition(\"B\", \"Off\")\n    mstate.descriptionUml(\"/auto=ON\")\n    mstate.declareStateTransition(\"A+B\", [\"Slow\"], function () {\n        // effect\n        auto = 1\n        mstate.traverse(StateMachines.M0, 0)\n    })\n})\n// State Slow\n// entry/\n// - reset blinkCount\n// do/ (500ms)\n// - LED blink\n// [Auto Mode] 6times\nmstate.defineState(StateMachines.M0, \"Slow\", function () {\n    mstate.declareEntry(function () {\n        times = 0\n    })\n    mstate.descriptionUml(\"LED blink (500ms)\")\n    mstate.declareDoActivity(500, function (counter) {\n        if (1 == auto && 6 <= counter) {\n            times = 6\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.descriptionUml(\"auto && 6times\")\n    mstate.declareStateTransition(\"\", [\"Fast\"], function () {\n        if (6 == times) {\n            mstate.traverse(StateMachines.M0, 0)\n        }\n    })\n    mstate.descriptionUml(\"/auto=OFF\")\n    mstate.declareStateTransition(\"A\", [\"Fast\"], function () {\n        // effect\n        auto = 0\n        mstate.traverse(StateMachines.M0, 0)\n    })\n    mstate.descriptionUml(\":\")\n    mstate.declareSimpleTransition(\"B\", \"Off\")\n})\ninput.onButtonPressed(Button.AB, function () {\n    mstate.sendTrigger(StateMachines.M0, \"A+B\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.sendTrigger(StateMachines.M0, \"B\")\n})\nlet auto = 0\nlet times = 0\nlet blinkNext = 0\nmstate.start(StateMachines.M0, \"Off\")\nmstate.exportUml(StateMachines.M0, \"Off\")\n"}