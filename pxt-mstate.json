{"README.md":"\n> Open this page at GitHub Pages: [https://jp-rad.github.io/pxt-mstate/](https://jp-rad.github.io/pxt-mstate/)\n\n## Creating Extensions\n\nExtensions are PXTâ€™s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\n\n* [MakeCode extensions](https://makecode.com/extensions)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-rad/pxt-mstate** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-rad/pxt-mstate/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-rad/pxt-mstate** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-rad/pxt-mstate/raw/master/.github/statics/blocks.png)\n\n\n**Example**\n\n```javascript\nfunction blinkLED () {\n    led.setBrightness(blink * 155 + 100)\n    blink += 1\n    blink = blink % 2\n}\nmstate.defineState(StateMachines.M0, \"State1\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        blink = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareDo(machine, state, 500, function () {\n        blinkLED()\n    })\n    mstate.declareExit(machine, state, function () {\n        led.setBrightness(255)\n        basic.showIcon(IconNames.Happy)\n    })\n    mstate.declareSimpleTransition(machine, state, \"Trigger1\", \"\")\n})\ninput.onButtonPressed(Button.A, function () {\n    mstate.start(StateMachines.M0, \"State1\")\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(StateMachines.M0, \"Trigger1\", [])\n})\nlet blink = 0\nmstate.exportUml(StateMachines.M0, \"State1\")\n\n```\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","enums.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","mstate.cpp":"#include \"pxt.h\"\n\nnamespace mstate {\n    \n    //%\n    void simu_export_uml(int v, StringData* s) {\n        // only for the simulator\n    }\n\n    //%\n    void simu_state_uml(int v, StringData* s) {\n        // only for the simulator\n    }\n\n    //%\n    void simu_transition_uml(int v, int s, StringData** a) {\n        // only for the simulator\n    }\n\n\n}","mstate.ts":"enum StateMachines {\r\n    M0 = 0,\r\n    M1,\r\n    M2,\r\n    M3,\r\n    M4,\r\n    M5\r\n}\r\n\r\n/**\r\n * mstate blocks\r\n * Defining blocks: https://makecode.com/defining-blocks\r\n * Playground: https://makecode.com/playground\r\n * icon: a Unicode identifier for an icon from the Font Awesome icon set.\r\n *       http://fontawesome.io/icons\r\n */\r\n//% weight=100 color=\"#4C97FF\" icon=\"\\uf362\"\r\n//% groups=\"['Command', 'Declare', 'Transit']\"\r\nnamespace mstate {\r\n\r\n    const MICROBIT_CUSTOM_ID_BASE = 32768\r\n    const DEFAULT_UPDATE_EVENT_ID = MICROBIT_CUSTOM_ID_BASE + 100\r\n    const DEFAULT_EVENT_LOOP_INTERVAL = 100\r\n\r\n    /**\r\n     * state/trigger id:name\r\n     */\r\n    namespace mname {\r\n        /**\r\n         * id:0 - INITIAL/FINAL/Completion Transition.\r\n         */\r\n        export const NONE_ID = 0   // id:0 - INITIAL/FINAL/Completion Transition\r\n\r\n        /**\r\n         * name:\"\" - INITIAL/FINAL/Completion Transition.\r\n         */\r\n        export const NONE_STR = \"\"\r\n\r\n        /**\r\n         * array of state/trigger name, index is id.\r\n         * default: [NONE_STR,]\r\n         */\r\n        let nameList: string[] = [NONE_STR,]\r\n\r\n        /**\r\n         * get id, new if undefined\r\n         * @param name state name or trigger name\r\n         * @returns state/trigger id\r\n         */\r\n        export function getIdOrNew(name: string) {\r\n            let idx = nameList.indexOf(name)\r\n            if (0 > idx) {\r\n                idx = nameList.length\r\n                nameList.push(name)\r\n            }\r\n            return idx\r\n        }\r\n\r\n        /**\r\n         * get name\r\n         * @param id state/trigger id\r\n         * @returns state/trigger name: \"[<id>]\" if undefined id\r\n         */\r\n        export function getName(id: number) {\r\n            if (0 <= id && nameList.length > id) {\r\n                return nameList[id]\r\n            }\r\n            return \"[\" + id + \"]\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * state machine\r\n     */\r\n    namespace mmachine {\r\n\r\n        /**\r\n         * transition canceled\r\n         */\r\n        const TRANSITION_CANCELED = -1\r\n\r\n        /**\r\n         * Entry/Exit Action\r\n         */\r\n        export class EntryExitAction {\r\n\r\n            /**\r\n             * execute Entry.\r\n             */\r\n            execute: () => void\r\n\r\n            /**\r\n             * constructor\r\n             * @param cb code to run\r\n             */\r\n            constructor(cb: () => void) {\r\n                this.execute = cb\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Do Activity\r\n         */\r\n        export class DoActivity {\r\n\r\n            // callback\r\n            _cb: () => void\r\n            _ms: number\r\n            nextTick: number\r\n\r\n            /**\r\n             * constructor\r\n             * @param ms interval (ms)\r\n             * @param cb code to run\r\n             */\r\n            constructor(ms: number, cb: () => void) {\r\n                this._cb = cb\r\n                this._ms = ms\r\n                //this._nextTick = -1\r\n            }\r\n\r\n            /**\r\n             * execute DO\r\n             * @param tick the number of milliseconds elapsed since power on, control.millis().\r\n             */\r\n            execute(tick: number) {\r\n                if (tick > this.nextTick) {\r\n                    this._cb()\r\n                    this.nextTick = tick + this._ms\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Transition\r\n         */\r\n        export class Transition {\r\n            /**\r\n             * array of state id, transition to.\r\n             */\r\n            toList: number[]\r\n            /**\r\n             * trigger id.\r\n             */\r\n            trigger: number\r\n            /**\r\n             * execute Transition.\r\n             * @param triggerArgs trigger args. \r\n             */\r\n            execute: (triggerArgs: number[]) => void\r\n\r\n            /**\r\n             * constructor\r\n             * @param toList array of state id, transition to\r\n             * @param trigger trigger id\r\n             * @param cb run to code, (triggerArgs: number[]) => void\r\n             */\r\n            constructor(toList: number[], trigger: number, cb: (triggerArgs: number[]) => void) {\r\n                this.toList = toList\r\n                this.trigger = trigger\r\n                this.execute = cb\r\n            }\r\n        }\r\n\r\n        class State {\r\n            /**\r\n             * state id.\r\n             */\r\n            state: number\r\n            /**\r\n             * array of entry action\r\n             */\r\n            entryActions: EntryExitAction[]\r\n            /**\r\n             * array of do activity\r\n             */\r\n            doActivities: DoActivity[]\r\n            /**\r\n             * array of exit action\r\n             */\r\n            exitActions: EntryExitAction[]\r\n            /**\r\n             * array of transition\r\n             */\r\n            transitions: Transition[]\r\n\r\n            constructor(state: number) {\r\n                this.state = state\r\n                this.entryActions = []\r\n                this.doActivities = []\r\n                this.exitActions = []\r\n                this.transitions = []\r\n            }\r\n        }\r\n\r\n        /**\r\n         * trigger and args\r\n         */\r\n        class TriggerWithArgs {\r\n            /**\r\n             * trigger id.\r\n             */\r\n            trigger: number\r\n            /**\r\n             * trigger args.\r\n             */\r\n            args: number[]\r\n\r\n            /**\r\n             * constructor\r\n             * @param trigger trigger id\r\n             * @param args trigger args\r\n             */\r\n            constructor(trigger: number, args: number[]) {\r\n                this.trigger = trigger\r\n                this.args = args\r\n            }\r\n        }\r\n\r\n        enum ProcState {\r\n            Idle,\r\n            Start,\r\n            Into,\r\n            Enter,\r\n            Do,\r\n            CompletionTransit,\r\n            Pause,\r\n            TriggeredTransit,\r\n            Exit\r\n        }\r\n\r\n        class StateMachine {\r\n\r\n            /**\r\n             * machine id\r\n             */\r\n            machine: number\r\n\r\n            // system\r\n            _initialized: boolean\r\n            _updateEventId: number\r\n            _eventLoopInterval: number\r\n\r\n            /**\r\n             * next proc\r\n             */\r\n            _procNext: ProcState\r\n\r\n            /**\r\n             * default state id for start.\r\n             */\r\n            _defaultState: number\r\n\r\n            /**\r\n             * array of state.\r\n             */\r\n            _states: State[]\r\n\r\n            /**\r\n             * current state\r\n             */\r\n            _state: State\r\n\r\n            /**\r\n             * trigger queue, array of TriggerWithArgs.\r\n             */\r\n            _triggerQueue: TriggerWithArgs[]\r\n\r\n            // selectable taransition\r\n            _selectedToAt: number   // >=0: selected, TRANSITION_CANCELED: unselected\r\n\r\n            // current transition\r\n            _transitTo: number\r\n\r\n            // reset on into.\r\n            _timeoutMillis: number\r\n\r\n            /**\r\n             * constructor\r\n             * The state machine ID is used as the event value, so it must be greater than 0\r\n             * @param machine state machine ID (>0)\r\n             */\r\n            constructor(machine: number) {\r\n                this.machine = machine\r\n                // system\r\n                this._initialized = false\r\n                this._updateEventId = DEFAULT_UPDATE_EVENT_ID\r\n                this._eventLoopInterval = DEFAULT_EVENT_LOOP_INTERVAL\r\n                this._defaultState = mname.NONE_ID\r\n\r\n                this._states = []\r\n\r\n                // current\r\n                this._state = undefined\r\n\r\n                // (Triggers[]) triggers\r\n                this._triggerQueue = []\r\n\r\n                // current transition\r\n                this._transitTo = TRANSITION_CANCELED\r\n\r\n                // selectable taransition\r\n                this._selectedToAt = TRANSITION_CANCELED\r\n\r\n                // proc\r\n                this._procNext = ProcState.Idle\r\n\r\n            }\r\n\r\n            /**\r\n             * get State instance, or new.\r\n             * @param stete state id\r\n             * @returns instance of State, undefined if NONE_ID. \r\n             */\r\n            getStateOrNew(state: number) {\r\n                if (mname.NONE_ID < state) {\r\n                    const obj = this._states.find(item => state == item.state)\r\n                    if (undefined !== obj) {\r\n                        return obj\r\n                    }\r\n                    const newObj = new State(state)\r\n                    this._states.push(newObj)\r\n                    return newObj\r\n                }\r\n                return undefined\r\n            }\r\n\r\n            _doCallbackSelectable(transition: Transition, triggerArgs: number[]) {\r\n                this._selectedToAt = TRANSITION_CANCELED    // reset\r\n                transition.execute(triggerArgs)             // callback\r\n                if (0 <= this._selectedToAt && transition.toList.length > this._selectedToAt) {\r\n                    // selected\r\n                    this._transitTo = transition.toList[this._selectedToAt]\r\n                    return true\r\n                }\r\n                return false\r\n            }\r\n\r\n            // Completion Transition\r\n            _procCompletionTransition() {\r\n                const emptyArgs: number[] = []\r\n                const transitions = this._state.transitions.filter(item => mname.NONE_ID == item.trigger)\r\n                for (const transition of transitions) {\r\n                    if (this._doCallbackSelectable(transition, emptyArgs)) {\r\n                        return true\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n\r\n            // Triggered Transition\r\n            _procTriggeredTransition() {\r\n                while (0 < this._triggerQueue.length) {\r\n                    const triggerAndArgs = this._triggerQueue.shift()\r\n                    const transitions = this._state.transitions.filter(item => triggerAndArgs.trigger == item.trigger)\r\n                    for (const transition of transitions) {\r\n                        if (this._doCallbackSelectable(transition, triggerAndArgs.args)) {\r\n                            return true\r\n                        }\r\n                    }\r\n                }\r\n                return false\r\n            }\r\n\r\n            _update() {\r\n                let loop = true\r\n                do {\r\n                    switch (this._procNext) {\r\n                        case ProcState.Start:\r\n                            this._transitTo = this._defaultState\r\n                            this._procNext = ProcState.Into\r\n                            loop = false    // break\r\n                            break;\r\n                        case ProcState.Into:\r\n                            this._state = this.getStateOrNew(this._transitTo)\r\n                            this._timeoutMillis = control.millis()\r\n                            if (undefined !== this._state) {\r\n                                for (const v of this._state.doActivities) {\r\n                                    v.nextTick = -1\r\n                                }\r\n                                this._procNext = ProcState.Enter\r\n                            } else {\r\n                                // (INITIAL or FINAL)\r\n                                while (0 < this._triggerQueue.length) {\r\n                                    this._triggerQueue.shift()\r\n                                }\r\n                                this._procNext = ProcState.Idle\r\n                            }\r\n                            break;\r\n                        case ProcState.Enter:\r\n                            for (const v of this._state.entryActions) {\r\n                                v.execute()\r\n                            }\r\n                            this._procNext = ProcState.Do\r\n                            break;\r\n                        case ProcState.Do:\r\n                            const tick = control.millis()\r\n                            for (const v of this._state.doActivities) {\r\n                                v.execute(tick)\r\n                            }\r\n                            this._procNext = ProcState.CompletionTransit\r\n                            break;\r\n                        case ProcState.CompletionTransit:\r\n                            if (this._procCompletionTransition()) {\r\n                                this._procNext = ProcState.Exit\r\n                            } else {\r\n                                this._procNext = ProcState.Pause\r\n                                loop = false    // break\r\n                            }\r\n                            break;\r\n                        case ProcState.Pause:\r\n                            this._procNext = ProcState.TriggeredTransit\r\n                            break;\r\n                        case ProcState.TriggeredTransit:\r\n                            if (this._procTriggeredTransition()) {\r\n                                this._procNext = ProcState.Exit\r\n                            } else {\r\n                                this._procNext = ProcState.Do\r\n                            }\r\n                            break;\r\n                        case ProcState.Exit:\r\n                            for (const v of this._state.exitActions) {\r\n                                v.execute()\r\n                            }\r\n                            this._procNext = ProcState.Into\r\n                            break;\r\n                        case ProcState.Idle:\r\n                        default:\r\n                            loop = false    // break\r\n                            break;\r\n                    }\r\n                } while (loop)\r\n            }\r\n\r\n            start(state: number): boolean {\r\n                if (!this._initialized) {\r\n                    this._initialized = true\r\n                    const that: StateMachine = this\r\n                    // update event handler\r\n                    control.onEvent(this._updateEventId, this.machine, function () {\r\n                        that._update()\r\n                    })\r\n                    // update event loop\r\n                    loops.everyInterval(this._eventLoopInterval, function () {\r\n                        control.raiseEvent(that._updateEventId, that.machine)\r\n                    })\r\n                }\r\n                if (ProcState.Idle == this._procNext) {\r\n                    this._defaultState = state\r\n                    this._procNext = ProcState.Start\r\n                    this._update()\r\n                    return true\r\n                } else {\r\n                    return false\r\n                }\r\n            }\r\n\r\n            fire(trigger: number, args: number[]) {\r\n                if (ProcState.Idle != this._procNext) {\r\n                    // queuing\r\n                    const triggerArgs = new TriggerWithArgs(trigger, args)\r\n                    this._triggerQueue.push(triggerArgs)\r\n                    // update event\r\n                    control.raiseEvent(this._updateEventId, this.machine)\r\n                }\r\n            }\r\n        }\r\n\r\n        // state machine\r\n        let stateMachineList: StateMachine[] = []\r\n\r\n        export function getStateMachine(machine: StateMachines) {\r\n            const obj = stateMachineList.find(item => machine == item.machine)\r\n            if (obj) {\r\n                return obj\r\n            }\r\n            const newObj = new StateMachine(machine)\r\n            stateMachineList.push(newObj)\r\n            return newObj\r\n        }\r\n    }\r\n\r\n    function splitFirst(s: string) {\r\n        return s.split(\":\", 1)[0]\r\n    }\r\n\r\n    /**\r\n     * convert state/trigger name (string) to id (number): new id if undefined\r\n     * @param name state name (string) or trigger name (string)\r\n     * @returns state id or trigger id\r\n     */\r\n    //% block=\"id of $name\"\r\n    //% name.defl=\"a\"\r\n    //% weight=210\r\n    //% advanced=true\r\n    export function convId(name: string): number {\r\n        return mname.getIdOrNew(name)\r\n    }\r\n\r\n    /**\r\n     * convert id (number) to state/trigger name (string)\r\n     * @param id state id or trigger id\r\n     * @returns state name (string) or trigger name (string): \"[<id>]\" if undefined\r\n     */\r\n    //% block=\"name of $id\"\r\n    //% weight=200\r\n    //% advanced=true\r\n    export function convName(id: number): string {\r\n        return mname.getName(id)\r\n    }\r\n\r\n    /**\r\n     * Internal event settings\r\n     * @param aStateMachine StateMachines\r\n     * @param eventId Event ID (default: 32868 = 32768 + 100)\r\n     * @param ms Event loop interval (default: 100ms)\r\n     */\r\n    //% block=\"settings [$aStateMachine] event ID: $eventId every: $ms ms\"\r\n    //% aStateMachine.defl=StateMachines.M0\r\n    //% eventId.defl=32768\r\n    //% ms.shadow=\"timePicker\"\r\n    //% ms.defl=100\r\n    //% weight=190\r\n    //% advanced=true\r\n    export function settingsMachineEvent(aStateMachine: StateMachines, eventId: number, ms: number) {\r\n        const machine = mmachine.getStateMachine(aStateMachine)\r\n        if (!machine._initialized) {\r\n            machine._updateEventId = eventId\r\n            machine._eventLoopInterval = ms\r\n        }\r\n    }\r\n\r\n    /**\r\n     * define state\r\n     * @param aStateMachine StateMachines\r\n     * @param aStateName state name\r\n     * @param body code to run, (machine: machine ID, state: state ID)\r\n     */\r\n    //% block=\"define [$machine,$state] to $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=StateMachines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% draggableParameters=\"reporter\"\r\n    //% weight=180\r\n    //% group=\"Declare\"\r\n    export function defineState(aStateMachine: StateMachines, aStateName: string,\r\n        body: (machine: number, state: number) => void\r\n    ) {\r\n        body(aStateMachine, convId(splitFirst(aStateName)))\r\n        // uml\r\n        _simuStateUml(aStateMachine, aStateName)\r\n    }\r\n\r\n    /**\r\n     * declare ENTRY action.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on entry [$aMachine,$aState]\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% handlerStatement\r\n    //% weight=170\r\n    //% group=\"Declare\"\r\n    export function declareEntry(aMachine: number, aState: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).getStateOrNew(aState).entryActions.push(new mmachine.EntryExitAction(body))\r\n    }\r\n\r\n    /**\r\n     * declare DO activity.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aEvery interval time (milliseconds)\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on do [$aMachine,$aState] every $aEvery ms\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aEvery.shadow=\"timePicker\"\r\n    //% handlerStatement\r\n    //% weight=160\r\n    //% group=\"Declare\"\r\n    export function declareDo(aMachine: number, aState: number, aEvery: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).getStateOrNew(aState).doActivities.push(new mmachine.DoActivity(aEvery, body))\r\n    }\r\n\r\n    /**\r\n     * declare EXIT action.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param body code to run\r\n     */\r\n    //% block=\"on exit [$aMachine,$aState]\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% handlerStatement\r\n    //% weight=150\r\n    //% group=\"Declare\"\r\n    export function declareExit(aMachine: number, aState: number,\r\n        body: () => void\r\n    ) {\r\n        mmachine.getStateMachine(aMachine).getStateOrNew(aState).exitActions.push(new mmachine.EntryExitAction(body))\r\n    }\r\n\r\n    /**\r\n     * declare simple transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aTriggerName trigger name\r\n     * @param aToName next state nam\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] when $aTriggerName to $aToName\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% aToName.defl=\"a\"\r\n    //% inlineInputMode=inline\r\n    //% weight=140\r\n    //% group=\"Transition\"\r\n    export function declareSimpleTransition(aMachine: number, aState: number, aTriggerName: string, aToName: string) {\r\n        declareCustomTransition(aMachine, aState, aTriggerName, [aToName], function (args) {\r\n            mstate.transitTo(aMachine, 0)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * declare timeouted transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aMs timeout (ms)\r\n     * @param aToName next state name\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] timeouted $aMs to $aToName\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aMs.shadow=\"timePicker\"\r\n    //% aToName.defl=\"a\"\r\n    //% inlineInputMode=inline\r\n    //% weight=130\r\n    //% group=\"Transition\"\r\n    export function declareTimeoutedTransition(aMachine: number, aState: number, aMs: number, aToName: string) {\r\n        declareCustomTransition(aMachine, aState, \"\", [aToName], function (args) {\r\n            if (mstate.isTimeouted(aMachine, aMs)) {\r\n                mstate.transitTo(aMachine, 0)\r\n            }\r\n        })\r\n    }\r\n\r\n    /**\r\n     * declare custom transition.\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aTriggerName trigger name\r\n     * @param aTransList array of next state name \r\n     * @param body code to run\r\n     */\r\n    //% block=\"trasition [$aMachine,$aState] when $aTriggerName $args to $aTransList\"\r\n    //% aMachine.defl=0\r\n    //% aState.defl=0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% draggableParameters=\"reporter\"\r\n    //% handlerStatement\r\n    //% weight=120\r\n    //% group=\"Transition\"\r\n    export function declareCustomTransition(aMachine: number, aState: number, aTriggerName: string, aTransList: string[],\r\n        body: (args: number[]) => void\r\n    ) {\r\n        const trigger = convId(aTriggerName)\r\n        const toList: number[] = []\r\n        for (const s of aTransList) {\r\n            toList.push(convId(splitFirst(s)))\r\n        }\r\n        mmachine.getStateMachine(aMachine).getStateOrNew(aState).transitions.push(new mmachine.Transition(toList, trigger, body))\r\n        // uml\r\n        _simuTransitionUml(aMachine, aState, aTransList)\r\n    }\r\n\r\n    /**\r\n     * is timeouted.\r\n     * @param aMachine machine ID\r\n     * @param aMs timeout (milliseconds)\r\n     */\r\n    //% block=\"timeouted [$aMachine] $aMs\"\r\n    //% aMachine.defl=0\r\n    //% aMs.shadow=\"timePicker\"\r\n    //% weight=110\r\n    //% group=\"Transition\"\r\n    export function isTimeouted(aMachine: number, aMs: number): boolean {\r\n        return control.millis() > mmachine.getStateMachine(aMachine)._timeoutMillis + aMs\r\n    }\r\n\r\n    /**\r\n     * transit to.\r\n     * @param aMachine machine ID\r\n     * @param index states index]\r\n     */\r\n    //% block=\"transit [$aMachine] at $index\"\r\n    //% aMachine.defl=0\r\n    //% index.defl=0\r\n    //% weight=100\r\n    //% group=\"Transition\"\r\n    export function transitTo(aMachine: number, index: number) {\r\n        mmachine.getStateMachine(aMachine)._selectedToAt = index\r\n    }\r\n\r\n    /**\r\n     * fire trigger\r\n     * @param aStateMachine StateMachines\r\n     * @param aTriggerName trigger name\r\n     * @param aTriggerArgs args\r\n     */\r\n    //% block=\"fire $aStateMachine $aTriggerName $aTriggerArgs\"\r\n    //% aStateMachine.defl=StateMachines.M0\r\n    //% aTriggerName.defl=\"e\"\r\n    //% weight=90\r\n    //% group=\"Command\"\r\n    export function fire(aStateMachine: StateMachines, aTriggerName: string, aTriggerArgs: number[]) {\r\n        mmachine.getStateMachine(aStateMachine).fire(convId(aTriggerName), aTriggerArgs)\r\n    }\r\n\r\n    /**\r\n     * start state machine\r\n     * @param aStateMachine StateMachines\r\n     * @param aStateName default state name\r\n     */\r\n    //% block=\"start $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=StateMachines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% weight=80\r\n    //% group=\"Command\"\r\n    export function start(aStateMachine: StateMachines, aStateName: string) {\r\n        mmachine.getStateMachine(aStateMachine).start(convId(aStateName))\r\n    }\r\n\r\n    /**\r\n     * export UML, PlantUML\r\n     * PlantUML Web server: http://www.plantuml.com/plantuml/\r\n     * @param aStateMachine\r\n     * @param aStateName default state\r\n     */\r\n    //% block=\"UML $aStateMachine $aStateName\"\r\n    //% aStateMachine.defl=StateMachines.M0\r\n    //% aStateName.defl=\"a\"\r\n    //% weight=70\r\n    //% group=\"Command\"\r\n    //% shim=mstate::simu_export_uml\r\n    export function exportUml(aStateMachine: StateMachines, aStateName: string) {\r\n        // for the simulator\r\n        const cb = console.log\r\n        cb(\"@startuml\")\r\n        //cb(\"' PlantUML Web server:\")\r\n        cb(\"' http://www.plantuml.com/plantuml/\")\r\n        // top state - machine name\r\n        cb(\"state __M\" + aStateMachine + \"__ {\")\r\n\r\n        // start\r\n        cb(\"[*] --> \" + aStateName)\r\n\r\n        // target machine\r\n        const target = mmachine.getStateMachine(aStateMachine)\r\n        for (const state of target._states) {\r\n            // state\r\n            const descStatePart = (state as any)[\"descState\"] ? \" : \" + (state as any)[\"descState\"] : \"\"\r\n            cb(\"state \" + mstate.convName(state.state) + descStatePart)\r\n            for (const trans of state.transitions) {\r\n                // transition\r\n                const trigger = mstate.convName(trans.trigger)\r\n                for (const descTo of ((trans as any)[\"descToList\"] as string[])) {\r\n                    let arrow = true\r\n                    let toName: string\r\n                    let desc: string\r\n                    const pos = descTo.indexOf(\":\")\r\n                    if (0 <= pos) {\r\n                        toName = descTo.slice(0, pos)\r\n                        desc = descTo.slice(pos + 1)\r\n                    } else {\r\n                        toName = descTo\r\n                        desc = undefined\r\n                    }\r\n                    if (toName == \"\") {\r\n                        toName = \"[*]\"\r\n                    }\r\n                    let triggerPart = \"\"\r\n                    if (trigger) {\r\n                        triggerPart = triggerPart + trigger\r\n                    }\r\n                    if (desc) {\r\n                        if (\":\" == desc.charAt(0)) {\r\n                            arrow = false\r\n                            desc = desc.slice(1)\r\n                        }\r\n                        const a = desc.split(\"/\", 2)\r\n                        if (a[0]) {\r\n                            triggerPart = triggerPart + \" [\" + a[0] + \"]\"\r\n                        }\r\n                        if (a[1]) {\r\n                            triggerPart = triggerPart + \" / \" + a[1]\r\n                        }\r\n                    }\r\n                    if (triggerPart) {\r\n                        triggerPart = \" : \" + triggerPart\r\n                    }\r\n                    if (arrow) {\r\n                        cb(mstate.convName(state.state) + \" --> \" + toName + triggerPart)\r\n                    } else {\r\n                        cb(\"state \" + mstate.convName(state.state) + \": --> \" + toName + triggerPart)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        cb(\"}\") // top state - machine name\r\n        cb(\"@enduml\")\r\n    }\r\n\r\n    /**\r\n     * UML state\r\n     * @param aMachine  machine ID\r\n     * @param aStateName state name\r\n     */\r\n    //% block\r\n    //% shim=mstate::simu_state_uml\r\n    //% deprecated=true\r\n    export function _simuStateUml(aMachine: number, aStateName: string) {\r\n        // for the simulator\r\n        const pos = aStateName.indexOf(\":\")\r\n        if (0 <= pos) {\r\n            const name = aStateName.slice(0, pos)\r\n            const state: any = mmachine.getStateMachine(aMachine).getStateOrNew(convId(name))\r\n            state[\"descState\"] = aStateName.slice(pos + 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * UML transition\r\n     * @param aMachine machine ID\r\n     * @param aState state ID\r\n     * @param aTransList array of next state name\r\n     */\r\n    //% block\r\n    //% shim=mstate::simu_transition_uml\r\n    //% deprecated=true\r\n    export function _simuTransitionUml(aMachine: number, aState: number, aTransList: string[]) {\r\n        // for the simulator\r\n        const state = mmachine.getStateMachine(aMachine).getStateOrNew(aState)\r\n        const lastTrans: any = state.transitions[(state.transitions.length - 1)]\r\n        lastTrans[\"descToList\"] = aTransList\r\n    }\r\n\r\n}\r\n","pxt.json":"{\n    \"name\": \"pxt-mstate\",\n    \"version\": \"0.5.4\",\n    \"description\": \"Let's try state machine with micro:bit!\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"mstate.cpp\",\n        \"mstate.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.17\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n\n// Auto-generated. Do not edit. Really.\n","test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\n\n// blink\nfunction blinkLED() {\n    if (0 == blinkNext) {\n        blinkNext = 1\n        led.setBrightness(100)\n    } else {\n        blinkNext = 0\n        led.setBrightness(255)\n    }\n}\n\n// State Off\n// entry/\n// - LED off\nmstate.defineState(StateMachines.M0, \"Off:LED off\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        basic.clearScreen()\n    })\n    mstate.declareExit(machine, state, function () {\n        led.setBrightness(255)\n        basic.showString(\"On!\")\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"On\")\n})\n\n// Stete On\n// entry/\n// - Initialize On/Blink\n// - LED Heart\nmstate.defineState(StateMachines.M0, \"On:auto=OFF\\\\nHeart icon\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        auto = 0\n        led.setBrightness(255)\n        blinkNext = 0\n        basic.showIcon(IconNames.Heart)\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"Slow\")\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off::\")\n    mstate.declareCustomTransition(machine, state, \"A+B\", [\"Slow:/auto=ON\"], function () {\n        mstate.transitTo(machine, 0)\n        // effect\n        auto = 1\n    })\n})\n\n// State Slow\n// entry/\n// - reset blinkCount\n// do/ (500ms)\n// - LED blink\n// [Auto Mode] 6times\nmstate.defineState(StateMachines.M0, \"Slow:LED blink (500ms)\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        blinkCount = 0\n    })\n    mstate.declareDo(machine, state, 500, function () {\n        blinkCount += 1\n        if (1 == auto && 6 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareCustomTransition(machine, state, \"\", [\"Fast:auto && 6times\"], function (args) {\n        if (0 > blinkCount) {\n            mstate.transitTo(machine, 0)\n        }\n    })\n    mstate.declareCustomTransition(machine, state, \"A\", [\"Fast:/auto=OFF\"], function () {\n        mstate.transitTo(machine, 0)\n        // effect\n        auto = 0\n    })\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off::\")\n})\n\n// State Fast\n// entry/\n// - reset blinkCount\n// do/ (200ms)\n// - LED blink\n// [Auto Mode] 15times\nmstate.defineState(StateMachines.M0, \"Fast:LED blink (200ms)\", function (machine, state) {\n    mstate.declareEntry(machine, state, function () {\n        blinkCount = 0\n    })\n    mstate.declareDo(machine, state, 200, function () {\n        blinkCount += 1\n        if (1 == auto && 15 < blinkCount) {\n            blinkCount = -1\n        } else {\n            blinkLED()\n        }\n    })\n    mstate.declareCustomTransition(machine, state, \"\", [\"Slow:auto && 15times\"], function (args) {\n        if (0 > blinkCount) {\n            mstate.transitTo(machine, 0)\n        }\n    })\n    mstate.declareSimpleTransition(machine, state, \"A\", \"On\")\n    mstate.declareSimpleTransition(machine, state, \"B\", \"Off::\")\n    mstate.declareTimeoutedTransition(machine, state, 5000, \"On:>5s\")\n})\n\ninput.onButtonPressed(Button.A, function () {\n    mstate.fire(StateMachines.M0, \"A\", [])\n})\ninput.onButtonPressed(Button.AB, function () {\n    mstate.fire(StateMachines.M0, \"A+B\", [])\n})\ninput.onButtonPressed(Button.B, function () {\n    mstate.fire(StateMachines.M0, \"B\", [])\n})\nlet auto = 0\nlet blinkCount = 0\nlet blinkNext = 0\nmstate.start(StateMachines.M0, \"Off\")\nmstate.exportUml(StateMachines.M0, \"Off\")\n"}